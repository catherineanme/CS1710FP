<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes"
    />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta
      name="format-detection"
      content="telephone=no, email=no, address=no"
    />
    <meta name="theme-color" content="#ffffff" />
    <title>Unity in Central Namibia: The Path to Power</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <link rel="stylesheet" href="css/styles.css" />
    <link rel="stylesheet" href="css/presentation.css" />
  </head>
  <body>
    <!-- Page Progress Bar -->
    <div class="page-progress-bar">
      <div class="page-progress-fill"></div>
    </div>

    <!-- Page Navigation Controls -->
    <div class="page-nav">
      <button class="page-nav-btn" id="prev-page">← Previous</button>
      <div class="page-indicator">
        <span class="current-page">1</span> /
        <span class="total-pages">12</span>
      </div>
      <button class="page-nav-btn" id="next-page">Next →</button>
    </div>

    <!-- Page Dots Navigation -->
    <div class="page-dots">
      <div class="page-dot active" data-page-name="Welcome"></div>
      <div class="page-dot" data-page-name="Introduction"></div>
      <div class="page-dot" data-page-name="Electoral Landscape"></div>
      <div class="page-dot" data-page-name="Closest Races"></div>
      <div class="page-dot" data-page-name="Geographic Targeting"></div>
      <div class="page-dot" data-page-name="Projected Outcomes"></div>
      <div class="page-dot" data-page-name="Electoral Shift"></div>
      <div class="page-dot" data-page-name="Coalition Analysis"></div>
      <div class="page-dot" data-page-name="Competitiveness"></div>
      <div class="page-dot" data-page-name="Fragmentation"></div>
      <div class="page-dot" data-page-name="Power Scenarios"></div>
      <div class="page-dot" data-page-name="Regional Composition"></div>
    </div>

    <!-- Keyboard Hint -->
    <div class="keyboard-hint">
      <span>Use</span>
      <kbd>←</kbd>
      <kbd>→</kbd>
      <span>or</span>
      <kbd>Space</kbd>
      <span>to navigate</span>
    </div>

    <!-- Keyboard Shortcuts Modal (keep from original) -->
    <div class="shortcuts-modal" id="shortcuts-modal">
      <div class="shortcuts-content">
        <h3>⌨️ Keyboard Shortcuts</h3>
        <div class="shortcut-item">
          <span class="shortcut-key">H</span>
          <span class="shortcut-desc">Show/hide this help menu</span>
        </div>
        <div class="shortcut-item">
          <span class="shortcut-key">← →</span>
          <span class="shortcut-desc">Navigate between pages</span>
        </div>
        <div class="shortcut-item">
          <span class="shortcut-key">Space</span>
          <span class="shortcut-desc">Next page</span>
        </div>
        <div class="shortcut-item">
          <span class="shortcut-key">1-9</span>
          <span class="shortcut-desc">Jump to page 1-9</span>
        </div>
        <div class="shortcut-item">
          <span class="shortcut-key">Home</span>
          <span class="shortcut-desc">Go to first page</span>
        </div>
        <div class="shortcut-item">
          <span class="shortcut-key">End</span>
          <span class="shortcut-desc">Go to last page</span>
        </div>
        <div class="shortcut-item">
          <span class="shortcut-key">Esc</span>
          <span class="shortcut-desc">Close modals</span>
        </div>
        <div
          style="
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
          "
        >
          <button
            onclick="document.getElementById('shortcuts-modal').classList.remove('active')"
            style="
              padding: 10px 24px;
              background: linear-gradient(135deg, #5a67d8 0%, #4c51bf 100%);
              color: #ffffff;
              border: none;
              border-radius: 8px;
              cursor: pointer;
              font-size: 1em;
              font-weight: 600;
            "
          >
            Close
          </button>
        </div>
      </div>
    </div>

    <!-- Right-side detail panel for constituency details (keep from original) -->
    <div id="constituency-detail-panel" class="constituency-detail-panel">
      <button class="close-button" id="close-detail-panel">×</button>
      <div id="detail-content"></div>
    </div>

    <!-- Loading Screen (keep from original) -->
    <div id="loading-screen" class="loading">
      <h2>Loading Election Data...</h2>
      <div class="loading-spinner"></div>
      <p>Processing 125 constituencies across Namibia</p>
    </div>

    <!-- Pages Wrapper -->
    <div class="pages-wrapper" id="main-content" style="display: none">
      <!-- PAGE 0: Title -->
      <div class="page active" data-page="0">
        <div class="page-content">
          <h1>
            Electoral Strategy Analysis:<br />Opposition Coordination in Namibia
          </h1>
          <p class="subtitle">
            A data-driven examination of vote fragmentation and strategic
            pathways to electoral competitiveness
          </p>
          <button class="start-btn" id="start-btn">Begin Exploration →</button>
        </div>
      </div>

      <!-- PAGE 1: Introduction -->
      <div class="page" data-page="1">
        <div class="page-content">
          <h2 class="page-title">About This Project</h2>
          <p class="page-subtitle">
            This interactive visualization analyzes Namibia's 2014 and 2019
            parliamentary elections to examine how vote fragmentation across
            opposition parties has enabled SWAPO to maintain electoral
            dominance.
          </p>

          <div class="intro-cards-presentation">
            <div class="intro-card">
              <h3>Our Goal</h3>
              <p>
                To demonstrate how strategic opposition coordination could
                fundamentally alter electoral outcomes in Namibia. By analyzing
                vote distribution patterns, we identify opportunities where
                coalition building could transform fragmented opposition support
                into competitive electoral challenges.
              </p>
            </div>

            <div class="intro-card">
              <h3>The Data</h3>
              <p>
                Our analysis encompasses 125 constituencies across Namibia's 14
                regions, examining detailed election results from 2014 and 2019.
                The dataset includes vote shares for all competing parties,
                constituency-level margins, turnout data, and geographic
                information.
              </p>
            </div>

            <div class="intro-card">
              <h3>What We Accomplish</h3>
              <p>
                We provide actionable insights for opposition parties by
                identifying high-priority target constituencies, modeling
                coalition scenarios, and quantifying the potential impact of
                coordination.
              </p>
            </div>
          </div>

          <h3 class="authors-section-title">Meet the Team</h3>
          <div class="authors-grid">
            <a
              href="https://www.linkedin.com/in/nathanielberkman/"
              target="_blank"
              class="author-card"
            >
              <div class="author-image-wrapper">
                <img
                  src="images/nathaniel.JPG"
                  alt="Nathaniel Berkman"
                  class="author-image"
                />
                <div class="linkedin-badge">
                  <svg
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                  >
                    <path
                      d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"
                    />
                  </svg>
                </div>
              </div>
              <h4 class="author-name">Nathaniel Berkman</h4>
              <p class="author-bio">
                Nathaniel Berkman is a student at Harvard University pursuing a
                concentration in Computer Science and Philosophy, bringing a
                thoughtful approach to the intersection of technology, ethics,
                and data analysis. His diverse involvement across campus
                includes active membership in The Harvard Lampoon, the Harvard
                Financial Analysts Club (HFAC), the Harvard Undergraduate Sports
                Lab, and Harvard Club Competitive Tennis, reflecting his
                commitment to both intellectual rigor and collaborative
                engagement. Nathaniel is dedicated to creating accessible and
                impactful visualizations that make complex data understandable,
                with particular interests spanning data science, political
                analysis, information visualization, and statistical modeling.
                His philosophical training enhances his ability to critically
                examine the implications of data-driven insights, ensuring that
                visualizations serve both analytical and ethical purposes in
                understanding electoral systems.
              </p>
              <div class="author-link-hint">View LinkedIn Profile →</div>
            </a>

            <a
              href="https://www.linkedin.com/in/catherine-mignone-38204b279/"
              target="_blank"
              class="author-card"
            >
              <div class="author-image-wrapper">
                <img
                  src="images/catherine.JPG"
                  alt="Catherine Mignone"
                  class="author-image"
                />
                <div class="linkedin-badge">
                  <svg
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                  >
                    <path
                      d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"
                    />
                  </svg>
                </div>
              </div>
              <h4 class="author-name"> Project Group Leader: Catherine Mignone </h4>
              <p class="author-bio">
                Catherine Mignone is a student at Harvard University pursuing a
                joint concentration in Government and History of Art and
                Architecture, with a secondary field in Computer Science,
                graduating in 2026. She brings a unique interdisciplinary
                perspective to data visualization, combining her passion for
                political systems with technical expertise in computational
                analysis. As a former member of Women's Varsity Rugby and
                current Commodore of Varsity Sailing, Catherine demonstrates
                leadership both on and off the field and water. Her commitment to research
                is evident through her role as a Harvard College Research
                Program Summer 2025 Fellow, where she conducted thesis research
                in Namibia, directly informing the electoral analysis presented
                in this visualization. Catherine is passionate about using
                data-driven insights to understand complex political systems and
                electoral dynamics through interactive visualizations and
                statistical analysis.
              </p>
              <div class="author-link-hint">View LinkedIn Profile →</div>
            </a>

            <a
              href="https://www.linkedin.com/in/matteo-wakeman-b6bb44201/"
              target="_blank"
              class="author-card"
            >
              <div class="author-image-wrapper">
                <img
                  src="images/matteo.JPG"
                  alt="Matteo Wakeman"
                  class="author-image"
                />
                <div class="linkedin-badge">
                  <svg
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                  >
                    <path
                      d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"
                    />
                  </svg>
                </div>
              </div>
              <h4 class="author-name">Matteo Wakeman</h4>
              <p class="author-bio">
                Matteo Wakeman is a senior at Harvard University with strong
                interests in both finance and music, bringing a unique blend of
                analytical thinking and creative expression to data
                visualization. As an incoming Investment Banking Summer Analyst
                at Goldman Sachs, he applies rigorous quantitative analysis to
                complex financial systems. Matteo founded the Harvard
                Undergraduate Music Business Association (HUMBA) to explore the
                artistic, legal, and business dimensions of the music industry,
                sharing these insights with fellow students. As a professional
                DJ, he has collaborated with over 10 hospitality groups to
                perform at more than 30 shows across Miami, Buenos Aires, New
                York City, and Boston, demonstrating his ability to connect with
                diverse audiences. This combination of business acumen and
                artistic expression informs his approach to creating accessible
                and engaging data visualizations that make complex information
                understandable.
              </p>
              <div class="author-link-hint">View LinkedIn Profile →</div>
            </a>
          </div>
        </div>
      </div>

      <!-- PAGE 2: Electoral Landscape -->
      <div class="page" data-page="2">
        <div class="page-content page-layout-map">
          <div class="map-section">
            <h2 class="page-title">
              <span class="section-number">1</span> Electoral Landscape
            </h2>
            <div class="map-container" id="map1">
              <button class="map-toggle-button" id="map1-toggle">
                Toggle Background
              </button>
            </div>
            <div class="legend" id="legend1"></div>
          </div>

          <div class="info-section">
            <div class="takeaway-box red">
              <strong>Key Takeaway:</strong> This map tells the story of a
              divided opposition. While SWAPO (red) dominates the electoral map,
              the real story isn't about overwhelming SWAPO support—it's about
              opposition fragmentation. In many constituencies, opposition
              parties collectively receive more votes than SWAPO, yet they lose
              because votes are split across 15+ different parties.
              <div class="takeaway-footer">
                <strong>Tip:</strong> Click on any constituency to view detailed
                election data and simulation scenarios.
              </div>
            </div>

            <div class="stats-grid" id="key-stats">
              <div class="stat-card">
                <div class="stat-label">Total Constituencies</div>
                <div class="stat-number" id="total-const">125</div>
              </div>
              <div class="stat-card">
                <div class="stat-label">SWAPO Wins</div>
                <div class="stat-number" id="swapo-const">96</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- PAGE 3: Closest Races -->
      <div class="page" data-page="3">
        <div class="page-content page-layout-chart">
          <h2 class="page-title">
            <span class="section-number">2</span> Closest Races
          </h2>
          <p class="page-subtitle">
            These constituencies were decided by the narrowest margins. Click
            any bar to explore that constituency in detail.
          </p>

          <div class="year-selector">
            <label class="year-label-title">Year:</label>
            <label class="year-option">
              <input type="radio" name="closest-year" value="2019" checked />
              <span>2019</span>
            </label>
            <label class="year-option">
              <input type="radio" name="closest-year" value="2014" />
              <span>2014</span>
            </label>
          </div>

          <div class="takeaway-box blue">
            <strong>Key Takeaway:</strong> The narrowest margins reveal where
            opposition coordination could have the greatest impact. In 2019, 15
            constituencies were decided by less than 5 percentage points—these
            represent the most immediate opportunities for strategic coalition
            building.
          </div>

          <div class="chart-container" id="closest-races-chart"></div>
        </div>
      </div>

      <!-- PAGE 4: Geographic Targeting -->
      <div class="page" data-page="4">
        <div class="page-content page-layout-map">
          <div class="map-section">
            <h2 class="page-title">Priority: Geographic Targeting</h2>
            <div class="map-container" id="map3">
              <button class="map-toggle-button" id="map3-toggle">
                Toggle Background
              </button>
            </div>
          </div>

          <div class="info-section">
            <div class="takeaway-box green">
              <strong>Key Takeaway:</strong> Geographic analysis identifies 18
              high-priority target constituencies where opposition parties
              collectively received more votes than SWAPO in 2019, yet lost due
              to fragmentation. These districts—concentrated in central and
              southern Namibia—represent the lowest-hanging fruit for coalition
              coordination.
            </div>

            <div class="constituency-list" id="target-constituencies"></div>
          </div>
        </div>
      </div>

      <!-- PAGE 5: Projected Outcomes -->
      <div class="page" data-page="5">
        <div class="page-content page-layout-map">
          <div class="map-section">
            <h2 class="page-title">
              <span class="section-number">3</span> Projected Outcomes
            </h2>
            <div class="map-container" id="map4">
              <button class="map-toggle-button" id="map4-toggle">
                Toggle Background
              </button>
            </div>
            <div class="legend" id="legend4"></div>
          </div>

          <div class="info-section">
            <div class="takeaway-box red">
              <strong>Key Takeaway:</strong> When we model a scenario where all
              opposition parties coordinate, the electoral map transforms
              dramatically. This projection reveals that in 35+ constituencies,
              combined opposition support already exceeds SWAPO's vote share—but
              fragmentation prevents these victories from materializing.
            </div>
          </div>
        </div>
      </div>

      <!-- PAGE 6: Electoral Shift -->
      <div class="page" data-page="6">
        <div class="page-content page-layout-map">
          <div class="map-section">
            <h2 class="page-title">
              <span class="section-number">4</span> Electoral Shift Analysis
            </h2>
            <div class="map-container" id="map-shift">
              <button class="map-toggle-button" id="map-shift-toggle">
                Toggle Background
              </button>
            </div>
            <div class="legend" id="legend-shift"></div>
          </div>

          <div class="info-section">
            <div class="takeaway-box cyan">
              <strong>Key Takeaway:</strong> The shift analysis reveals a mixed
              trend: while some constituencies became more competitive (blue
              areas), others saw margins widen (red areas). The blue
              constituencies—where margins narrowed—represent growing
              opportunities where opposition coordination could capitalize on
              increasing competitiveness.
            </div>
          </div>
        </div>
      </div>

      <!-- PAGE 7: Coalition Simulator -->
      <div class="page" data-page="7">
        <div class="page-content page-layout-coalition">
          <div class="coalition-controls">
            <h2 class="page-title">
              <span class="section-number">5</span> Coalition Scenario Analysis
            </h2>
            <p class="page-subtitle">
              Explore how different levels of opposition coordination would
              impact electoral results.
            </p>

            <div class="takeaway-box blue">
              <strong>Key Takeaway:</strong> This interactive model demonstrates
              that even partial coordination yields significant results. As you
              adjust the slider, watch how the map transforms: green
              constituencies multiply, revealing the latent power of opposition
              coordination.
            </div>

            <div class="coalition-slider-box">
              <label class="coalition-label">
                Number of Top Opposition Parties to Consolidate:
              </label>
              <div class="coalition-slider-controls">
                <input
                  type="range"
                  id="coalition-n"
                  min="1"
                  max="5"
                  step="1"
                  value="2"
                  class="coalition-slider"
                />
                <span id="coalition-n-value" class="coalition-value">2</span>
              </div>
            </div>

            <div id="coalition-kpis" class="coalition-kpis">
              <div class="kpi-label">Potential Constituency Flips:</div>
              <div id="flips-count" class="kpi-value">0</div>
            </div>
          </div>

          <div class="coalition-map-section">
            <div class="map-container" id="map-coalition">
              <button class="map-toggle-button" id="map-coalition-toggle">
                Toggle Background
              </button>
            </div>
            <div class="legend" id="legend-coalition"></div>
          </div>
        </div>
      </div>

      <!-- PAGE 8: Competitiveness -->
      <div class="page" data-page="8">
        <div class="page-content page-layout-chart">
          <div class="page-header">
            <h2 class="page-title">
              <span class="section-number">6</span> Competitiveness Analysis
            </h2>
            <div class="year-selector">
              <label class="year-label-title">Year:</label>
              <label class="year-option">
                <input type="radio" name="margin-year" value="2014" />
                <span>2014</span>
              </label>
              <label class="year-option">
                <input type="radio" name="margin-year" value="2019" checked />
                <span>2019</span>
              </label>
            </div>
          </div>
          <p class="page-subtitle">
            Distribution of winning margins across constituencies. Points below
            5% indicate highly competitive races.
          </p>

          <div class="takeaway-box orange">
            <strong>Key Takeaway:</strong> Constituencies clustering near the
            left (low margins) are competitive races where small voter shifts
            could change outcomes.
          </div>

          <div class="chart-container" id="margin-beeswarm"></div>
        </div>
      </div>

      <!-- PAGE 9: Fragmentation -->
      <div class="page" data-page="9">
        <div class="page-content page-layout-chart">
          <div class="page-header">
            <h2 class="page-title">
              <span class="section-number">7</span> Party Fragmentation (ENP by
              Region)
            </h2>
            <button
              id="clear-region-filter"
              class="filter-clear-btn"
              style="display: none"
            >
              Clear Filter
            </button>
          </div>

          <div class="takeaway-box red">
            <span
              ><strong>Key:</strong> Higher ENP = more vote splitting. Darker
              regions are prime coordination targets.</span
            >
            <span class="takeaway-footer"
              ><strong>Tip:</strong> Click any cell to filter the map.</span
            >
          </div>

          <div class="chart-container" id="enp-heatmap"></div>
        </div>
      </div>

      <!-- PAGE 10: Power Scenarios -->
      <div class="page" data-page="10">
        <div class="page-content page-layout-full">
          <h2 class="page-title">
            <span class="section-number">8</span> Power Scenarios Dashboard
          </h2>
          <p class="page-subtitle">
            Comparing electoral outcomes under different coordination scenarios.
          </p>

          <div class="takeaway-box purple">
            <strong>Key Takeaway:</strong> The numbers tell a clear story:
            coordination dramatically shifts the balance of power. Under
            baseline conditions (2019 actual results), SWAPO dominates with
            overwhelming seat majorities. But when we model even partial
            coordination, the seat distribution becomes competitive.
          </div>

          <div class="stats-grid" id="scenarios-kpis"></div>
          <div class="comparison-container" id="scenarios-cards"></div>
          <div style="height: 80px; flex-shrink: 0"></div>
        </div>
      </div>

      <!-- PAGE 11: Regional Composition -->
      <div class="page" data-page="11">
        <div class="page-content page-layout-full">
          <h2 class="page-title">
            <span class="section-number">9</span> Regional Vote Composition
          </h2>
          <p class="page-subtitle">
            Treemap visualization showing vote shares by party across Namibia's
            regions.
          </p>

          <div class="takeaway-box teal">
            <strong>Key Takeaway:</strong> The treemap reveals the geographic
            dimension of vote fragmentation. While SWAPO maintains large vote
            shares across most regions, opposition support is fragmented into
            many smaller parties. This makes clear that opposition parties
            collectively represent significant power—but that power is divided.
            <div class="takeaway-footer">
              <strong>Tip:</strong> Hover over rectangles for detailed party
              statistics. Click to filter the electoral map.
            </div>
          </div>

          <div class="year-selector">
            <label class="year-label-title" for="treemap-year">Year:</label>
            <select id="treemap-year" class="year-select-dropdown">
              <option value="2019">2019</option>
              <option value="2014">2014</option>
            </select>
          </div>

          <div class="chart-container" id="treemap-chart"></div>
        </div>
      </div>
    </div>

    <!-- Include all original JavaScript from the old HTML -->
    <script src="js/presentation.js"></script>
    <script>
      // Section scroll animations using Intersection Observer
      document.addEventListener("DOMContentLoaded", function () {
        // Show hero immediately on load
        const hero = document.querySelector(".hero");
        if (hero) {
          setTimeout(() => {
            hero.classList.add("visible");
          }, 100);
        }

        // Set up Intersection Observer for sections
        const observerOptions = {
          threshold: 0.1,
          rootMargin: "0px 0px -50px 0px",
        };

        const observer = new IntersectionObserver(function (entries) {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              entry.target.classList.add("visible");
            }
          });
        }, observerOptions);

        // Observe all sections, priority sections, and intro section
        const sections = document.querySelectorAll(
          ".section, .priority-section, .intro-section"
        );
        sections.forEach((section) => {
          observer.observe(section);
        });

        // ===== COOL FEATURES =====

        // 1. Reading Progress Bar
        const progressBar = document.getElementById("reading-progress");
        const updateProgress = () => {
          const windowHeight = window.innerHeight;
          const documentHeight = document.documentElement.scrollHeight;
          const scrollTop =
            window.pageYOffset || document.documentElement.scrollTop;
          const progress = (scrollTop / (documentHeight - windowHeight)) * 100;
          progressBar.style.width = Math.min(100, Math.max(0, progress)) + "%";
        };
        window.addEventListener("scroll", updateProgress);
        updateProgress();

        // 2. Scroll to Top Button
        const scrollToTopBtn = document.getElementById("scroll-to-top");
        const checkScrollTop = () => {
          if (window.pageYOffset > 300) {
            scrollToTopBtn.classList.add("visible");
          } else {
            scrollToTopBtn.classList.remove("visible");
          }
        };
        window.addEventListener("scroll", checkScrollTop);
        scrollToTopBtn.addEventListener("click", () => {
          window.scrollTo({ top: 0, behavior: "smooth" });
        });

        // 3. Quick Navigation Sidebar
        const quickNav = document.getElementById("quick-nav");
        const navDots = quickNav.querySelectorAll(".nav-dot");
        const sectionIds = [
          "intro-section",
          "section-1",
          "section-2",
          "section-3",
          "section-4",
          "section-5",
          "section-6",
          "section-7",
          "section-8",
          "section-9",
        ];

        // Show quick nav after scrolling
        window.addEventListener("scroll", () => {
          if (window.pageYOffset > 500) {
            quickNav.classList.add("visible");
          } else {
            quickNav.classList.remove("visible");
          }

          // Update active dot based on scroll position
          let currentSection = "";
          sectionIds.forEach((id, index) => {
            const section = document.getElementById(id);
            if (section) {
              const rect = section.getBoundingClientRect();
              if (rect.top <= 200 && rect.bottom >= 200) {
                currentSection = id;
                navDots.forEach((dot) => dot.classList.remove("active"));
                if (navDots[index]) navDots[index].classList.add("active");
              }
            }
          });
        });

        // Click navigation dots
        navDots.forEach((dot, index) => {
          dot.addEventListener("click", () => {
            const targetId = sectionIds[index];
            const target = document.getElementById(targetId);
            if (target) {
              target.scrollIntoView({ behavior: "smooth", block: "start" });
            }
          });
        });

        // 4. Keyboard Shortcuts
        const shortcutsModal = document.getElementById("shortcuts-modal");
        let currentFullscreenMap = null;

        document.addEventListener("keydown", (e) => {
          // Don't trigger shortcuts when typing in inputs
          if (e.target.tagName === "INPUT" || e.target.tagName === "TEXTAREA")
            return;

          // H - Show shortcuts (Help)
          if (
            (e.key === "h" || e.key === "H") &&
            !e.shiftKey &&
            !e.ctrlKey &&
            !e.metaKey
          ) {
            e.preventDefault();
            shortcutsModal.classList.toggle("active");
          }

          // Esc - Close modals/exit fullscreen
          if (e.key === "Escape") {
            shortcutsModal.classList.remove("active");
            if (currentFullscreenMap) {
              currentFullscreenMap.classList.remove("fullscreen");
              currentFullscreenMap = null;
            }
          }

          // T - Scroll to top
          if (
            (e.key === "t" || e.key === "T") &&
            !e.shiftKey &&
            !e.ctrlKey &&
            !e.metaKey
          ) {
            e.preventDefault();
            window.scrollTo({ top: 0, behavior: "smooth" });
          }

          // B - Scroll to bottom
          if (
            (e.key === "b" || e.key === "B") &&
            !e.shiftKey &&
            !e.ctrlKey &&
            !e.metaKey
          ) {
            e.preventDefault();
            window.scrollTo({
              top: document.documentElement.scrollHeight,
              behavior: "smooth",
            });
          }

          // 1-9 - Jump to sections
          const num = parseInt(e.key);
          if (num >= 1 && num <= 9) {
            const targetId = num === 1 ? "intro-section" : `section-${num - 1}`;
            const target = document.getElementById(targetId);
            if (target) {
              e.preventDefault();
              target.scrollIntoView({ behavior: "smooth", block: "start" });
            }
          }

          // F - Fullscreen maps
          if (e.key === "f" || e.key === "F") {
            const mapContainers = document.querySelectorAll(".map-container");
            mapContainers.forEach((map) => {
              const rect = map.getBoundingClientRect();
              if (rect.top < window.innerHeight && rect.bottom > 0) {
                e.preventDefault();
                if (currentFullscreenMap === map) {
                  map.classList.remove("fullscreen");
                  currentFullscreenMap = null;
                } else {
                  if (currentFullscreenMap) {
                    currentFullscreenMap.classList.remove("fullscreen");
                  }
                  map.classList.add("fullscreen");
                  currentFullscreenMap = map;
                }
              }
            });
          }
        });

        // Close shortcuts modal on background click
        shortcutsModal.addEventListener("click", (e) => {
          if (e.target === shortcutsModal) {
            shortcutsModal.classList.remove("active");
          }
        });

        // 5. Feature Discovery Badge
        const featureBadge = document.getElementById("feature-badge");
        let badgeShown = sessionStorage.getItem("featureBadgeShown");
        if (!badgeShown) {
          setTimeout(() => {
            featureBadge.classList.add("visible");
            setTimeout(() => {
              featureBadge.classList.remove("visible");
              sessionStorage.setItem("featureBadgeShown", "true");
            }, 5000);
          }, 3000);
        }
        featureBadge.addEventListener("click", () => {
          shortcutsModal.classList.add("active");
          featureBadge.classList.remove("visible");
        });

        // 6. Add Fullscreen Buttons to Maps
        const addFullscreenButtons = () => {
          document.querySelectorAll(".map-container").forEach((map) => {
            if (!map.querySelector(".fullscreen-btn")) {
              const btn = document.createElement("button");
              btn.className = "fullscreen-btn";
              btn.textContent = "⛶ Fullscreen";
              btn.title = "Press F for fullscreen";
              btn.addEventListener("click", () => {
                if (currentFullscreenMap === map) {
                  map.classList.remove("fullscreen");
                  currentFullscreenMap = null;
                  btn.textContent = "⛶ Fullscreen";
                } else {
                  if (currentFullscreenMap) {
                    currentFullscreenMap.classList.remove("fullscreen");
                  }
                  map.classList.add("fullscreen");
                  currentFullscreenMap = map;
                  btn.textContent = "⛶ Exit Fullscreen";
                }
              });
              map.style.position = "relative";
              map.appendChild(btn);
            }
          });
        };

        // Add fullscreen buttons after maps are created
        setTimeout(addFullscreenButtons, 2000);

        // 7. Animated Stat Counters
        const animateCounters = () => {
          const counters = document.querySelectorAll(".stat-number");
          counters.forEach((counter) => {
            const observer = new IntersectionObserver(
              (entries) => {
                entries.forEach((entry) => {
                  if (
                    entry.isIntersecting &&
                    !counter.classList.contains("animated")
                  ) {
                    counter.classList.add("animate", "animated");
                    const finalValue = counter.textContent;
                    if (!isNaN(parseInt(finalValue))) {
                      const target = parseInt(finalValue);
                      let current = 0;
                      const increment = target / 30;
                      const timer = setInterval(() => {
                        current += increment;
                        if (current >= target) {
                          counter.textContent = finalValue;
                          clearInterval(timer);
                        } else {
                          counter.textContent = Math.floor(current);
                        }
                      }, 50);
                    }
                  }
                });
              },
              { threshold: 0.5 }
            );
            observer.observe(counter);
          });
        };
        setTimeout(animateCounters, 1000);
      });

      // Coordinate transformation from EPSG:3857 (Web Mercator) to EPSG:4326 (WGS84)
      function transformCoordinates(coord) {
        const x = coord[0];
        const y = coord[1];
        const lon = (x / 20037508.34) * 180;
        let lat = (y / 20037508.34) * 180;
        lat =
          (180 / Math.PI) *
          (2 * Math.atan(Math.exp((lat * Math.PI) / 180)) - Math.PI / 2);
        return [lat, lon]; // Leaflet expects [lat, lon]
      }

      function transformRing(ring) {
        return ring.map((coord) => transformCoordinates(coord));
      }

      function transformPolygonCoords(coords) {
        return coords.map((ring) => transformRing(ring));
      }

      // Compute Leaflet bounds for a set of constituencies (using transformed polygon coords)
      function getNamibiaBounds(constituencies) {
        let bounds = null;
        constituencies.forEach((c) => {
          if (!c.geometry || !c.geometry.coordinates) return;
          const transformed = transformPolygonCoords(c.geometry.coordinates);
          transformed.forEach((ring) => {
            ring.forEach((latlng) => {
              const ll = L.latLng(latlng[0], latlng[1]);
              if (!bounds) bounds = L.latLngBounds(ll, ll);
              else bounds.extend(ll);
            });
          });
        });
        return bounds || L.latLngBounds(L.latLng(-28, 11), L.latLng(-16, 26));
      }

      // Color schemes
      const partyColors = {
        SWAPO: "#E74C3C",
        DTA: "#3498DB",
        PDM: "#9B59B6",
        "Popular Democratic Movement": "#9B59B6",
        RDP: "#F39C12",
        LPM: "#D35400",
        "Landless People's Movement": "#D35400",
        Independent: "#16A085",
        Opposition: "#3498DB",
        Coordinated: "#27AE60",
        Competitive: "#F39C12",
      };

      let processedData = {};
      let mapInstances = {}; // Store map instances to prevent duplicates

      // Helper function to safely remove existing map
      function removeExistingMap(containerId) {
        const container = document.getElementById(containerId);
        if (container && container._leaflet_id) {
          container._leaflet_id = undefined;
          // Find and preserve toggle button
          const toggleBtn = container.querySelector(".map-toggle-button");
          const toggleBtnHTML = toggleBtn ? toggleBtn.outerHTML : "";
          container.innerHTML = toggleBtnHTML;
        }
      }

      // Centralized function to check if a party is SWAPO (handles all variations)
      function isSWAPOParty(party) {
        if (!party) return false;

        const name = (party.name || "").toString().toUpperCase().trim();
        const abbr = (party.abbr || "").toString().toUpperCase().trim();

        // Check abbreviation for SWAPO
        if (abbr === "SWAPO" || abbr.includes("SWAPO")) {
          return true;
        }

        // Check abbreviation for "South West Africa People's Organisation" variants
        if (
          abbr.includes("SOUTH WEST AFRICA") ||
          abbr.includes("SOUTHWEST AFRICA") ||
          abbr.includes("SOUTH WEST AFRICAN") ||
          abbr.includes("SOUTHWEST AFRICAN")
        ) {
          return true;
        }

        // Check abbreviation for "People" combined with "South" or "Africa" (SWAPO variant)
        if (abbr.includes("PEOPLE")) {
          if (abbr.includes("SOUTH") || abbr.includes("AFRICA")) {
            return true;
          }
        }

        // Check name for SWAPO variations
        if (name.includes("SWAPO")) {
          return true;
        }

        // Check for SWAPO name variations (case-insensitive)
        if (
          name.includes("SOUTH WEST AFRICA") ||
          name.includes("SOUTHWEST AFRICA") ||
          name.includes("SOUTH WEST AFRICAN") ||
          name.includes("SOUTHWEST AFRICAN")
        ) {
          return true;
        }

        // Check for "People" combined with "South" or "Africa" (SWAPO variant)
        if (name.includes("PEOPLE")) {
          if (name.includes("SOUTH") || name.includes("AFRICA")) {
            return true;
          }
        }

        return false;
      }

      // Normalize party to SWAPO if it's a SWAPO variant
      function normalizeParty(party) {
        if (!party) return party;

        if (isSWAPOParty(party)) {
          return {
            ...party,
            name: "SWAPO",
            abbr: "SWAPO",
          };
        }
        return party;
      }

      // Helper function to get display name - always returns "SWAPO" for SWAPO variants
      function getDisplayPartyName(party) {
        if (!party) return "";
        if (isSWAPOParty(party)) {
          return "SWAPO";
        }
        return party.name || party.abbr || "";
      }

      // Helper function to get display abbreviation - always returns "SWAPO" for SWAPO variants
      function getDisplayPartyAbbr(party) {
        if (!party) return "";
        if (isSWAPOParty(party)) {
          return "SWAPO";
        }
        return party.abbr || party.name || "";
      }

      async function loadData() {
        try {
          const response = await fetch("./namibia.geojson");
          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);
          const geojsonData = await response.json();

          // Process data
          geojsonData.features.forEach((feature) => {
            const props = feature.properties;
            const key = `${props.NAME2}_${props.year}`;

            if (!processedData[key]) {
              processedData[key] = {
                name: props.NAME2,
                region: props.NAME1,
                year: props.year,
                geometry: feature.geometry,
                parties: [],
                totalVotes: props.total_votes,
                registered: props.reg,
                turnout: props.turnout_reg,
              };
            }

            // Create party object
            const party = {
              name: (props.party || "").trim(),
              abbr: (props.party_b || "").trim(),
              votes: props.votes,
              percentage: (props.votes / props.total_votes) * 100,
            };

            // Normalize all SWAPO variants to "SWAPO"
            const normalizedParty = normalizeParty(party);

            processedData[key].parties.push(normalizedParty);
          });

          // After normalization, combine duplicate parties (e.g., multiple SWAPO entries)
          Object.values(processedData).forEach((constituency) => {
            // Group parties by normalized name and abbreviation
            const partyMap = new Map();

            constituency.parties.forEach((party) => {
              // Re-normalize to ensure consistency (safety check)
              const normalized = normalizeParty(party);
              const key = `${normalized.name}|${normalized.abbr}`;

              if (partyMap.has(key)) {
                // Combine votes and recalculate percentage
                const existing = partyMap.get(key);
                existing.votes += normalized.votes;
                existing.percentage =
                  (existing.votes / constituency.totalVotes) * 100;
              } else {
                partyMap.set(key, { ...normalized });
              }
            });

            // Convert back to array and sort by votes
            constituency.parties = Array.from(partyMap.values());
            constituency.parties.sort((a, b) => b.votes - a.votes);

            // Recalculate winner and runner-up
            if (constituency.parties.length > 0) {
              constituency.winner = constituency.parties[0];
              constituency.runnerUp =
                constituency.parties.length > 1
                  ? constituency.parties[1]
                  : constituency.parties[0];
            }
          });

          document.getElementById("loading-screen").style.display = "none";
          document.getElementById("main-content").style.display = "block";
          updateStats();
          window.dataLoaded = true;
          window.dispatchEvent(new Event("dataReady"));
        } catch (error) {
          console.error("Error loading data:", error);
          document.getElementById("loading-screen").innerHTML = `
                    <div class="error-box">
                        <h3>⚠️ Error Loading Data</h3>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p><strong>Please ensure:</strong></p>
                        <ul>
                            <li>Both <code>index.html</code> and <code>namibia.geojson</code> are in the same folder</li>
                            <li>You're running a local server (not opening file:// directly)</li>
                            <li>Try: <code>python -m http.server 8000</code></li>
                            <li>Or use VS Code's Live Server extension</li>
                        </ul>
                        <p><button onclick="location.reload()">Retry</button></p>
                    </div>
                `;
        }
      }

      // Helper functions (must be defined after processedData is built)
      function getYearsAvailable() {
        return Array.from(
          new Set(Object.values(processedData).map((d) => d.year))
        ).sort();
      }

      function getByYear(year) {
        return Object.values(processedData).filter((c) => c.year === year);
      }

      function winnerColor(constituency) {
        const isSWAPO = isSWAPOParty(constituency.winner);
        return isSWAPO
          ? partyColors["SWAPO"]
          : partyColors[constituency.winner.abbr] || partyColors["Opposition"];
      }

      function createScenariosDashboard() {
        const constituencies2019 = getByYear(2019);

        // Helper function to create a mini map
        function createMiniMap(
          containerId,
          data,
          getColor,
          getTooltip,
          bounds
        ) {
          const map = L.map(containerId, {
            attributionControl: false,
            zoomControl: false,
            worldCopyJump: false,
          });
          map.fitBounds(bounds);
          map.setMaxBounds(bounds.pad(0.1));

          L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
            attribution: "",
            maxZoom: 19,
          }).addTo(map);

          data.forEach((item) => {
            if (
              item.constituency.geometry &&
              item.constituency.geometry.coordinates
            ) {
              const transformedCoords = transformPolygonCoords(
                item.constituency.geometry.coordinates
              );

              L.polygon(transformedCoords, {
                color: "#333",
                weight: 1,
                fillColor: getColor(item),
                fillOpacity: 0.6,
              })
                .bindTooltip(getTooltip(item), {
                  permanent: false,
                  sticky: true,
                  direction: "auto",
                  className: "custom-tooltip",
                })
                .addTo(map);
            }
          });

          // Disable interactions for thumbnail
          map.dragging.disable();
          map.touchZoom.disable();
          map.doubleClickZoom.disable();
          map.scrollWheelZoom.disable();
          map.boxZoom.disable();
          map.keyboard.disable();

          return map;
        }

        // Calculate baseline statistics
        const baselineResults = constituencies2019.map((constituency) => {
          const isSWAPO = isSWAPOParty(constituency.winner);
          const margin =
            constituency.winner.percentage - constituency.runnerUp.percentage;
          return {
            constituency,
            isSWAPO,
            margin,
            winnerName: isSWAPO ? "SWAPO" : "Opposition",
          };
        });

        const baselineSwapoSeats = baselineResults.filter(
          (r) => r.isSWAPO
        ).length;
        const baselineOppositionSeats = baselineResults.filter(
          (r) => !r.isSWAPO
        ).length;
        const baselineAvgMargin =
          baselineResults.reduce((sum, r) => sum + r.margin, 0) /
          baselineResults.length;

        // Scenario 1: Coalition N=2
        const coalitionResults = constituencies2019.map((constituency) => {
          // Separate SWAPO and opposition parties (parties are already normalized)
          const swapoParties = constituency.parties.filter((p) =>
            isSWAPOParty(p)
          );
          const oppositionParties = constituency.parties.filter(
            (p) => !isSWAPOParty(p)
          );

          // Sort opposition by percentage desc and sum top 2
          const sortedOpposition = [...oppositionParties].sort(
            (a, b) => b.percentage - a.percentage
          );
          const top2Opposition = sortedOpposition.slice(
            0,
            Math.min(2, sortedOpposition.length)
          );
          const coalitionPercentage = top2Opposition.reduce(
            (sum, p) => sum + p.percentage,
            0
          );

          // Get SWAPO percentage
          const swapoPercentage =
            swapoParties.length > 0
              ? swapoParties.reduce((sum, p) => sum + p.percentage, 0)
              : 0;

          // Determine winner and margin
          const isCoalitionWin = coalitionPercentage > swapoPercentage;
          const margin = isCoalitionWin
            ? coalitionPercentage - swapoPercentage
            : swapoPercentage - coalitionPercentage;

          const originalIsSWAPO =
            baselineResults.find(
              (r) => r.constituency.name === constituency.name
            )?.isSWAPO || false;
          const flipped = originalIsSWAPO && isCoalitionWin;

          return {
            constituency,
            isSWAPO: !isCoalitionWin,
            margin,
            flipped,
            winnerName: isCoalitionWin ? "Coalition" : "SWAPO",
          };
        });

        const coalitionSwapoSeats = coalitionResults.filter(
          (r) => r.isSWAPO
        ).length;
        const coalitionOppositionSeats = coalitionResults.filter(
          (r) => !r.isSWAPO
        ).length;
        const coalitionAvgMargin =
          coalitionResults.reduce((sum, r) => sum + r.margin, 0) /
          coalitionResults.length;
        const coalitionFlips = coalitionResults.filter((r) => r.flipped).length;

        // Scenario 2: Turnout +5pp (targets only)
        const turnoutResults = constituencies2019.map((constituency) => {
          // Calculate total non-SWAPO percentage (parties are already normalized)
          const swapoParties = constituency.parties.filter((p) =>
            isSWAPOParty(p)
          );
          const oppositionParties = constituency.parties.filter(
            (p) => !isSWAPOParty(p)
          );

          const swapoPercentage =
            swapoParties.length > 0
              ? swapoParties.reduce((sum, p) => sum + p.percentage, 0)
              : 0;
          const oppositionPercentage = oppositionParties.reduce(
            (sum, p) => sum + p.percentage,
            0
          );

          // Only apply to targets (non-SWAPO > 45%)
          if (oppositionPercentage <= 45) {
            // Not a target - return baseline result
            const baseline = baselineResults.find(
              (r) => r.constituency.name === constituency.name
            );
            return {
              constituency,
              isSWAPO: baseline.isSWAPO,
              margin: baseline.margin,
              flipped: false,
              winnerName: baseline.winnerName,
              isTarget: false,
            };
          }

          // Simulate +5pp turnout boost for opposition
          // Add 5pp to opposition total, then renormalize all parties
          const newOppositionTotal = oppositionPercentage + 5;
          const totalAfterBoost = swapoPercentage + newOppositionTotal;

          // Renormalize factor (to get back to 100%)
          const renormalizeFactor = 100 / totalAfterBoost;

          // Scale all parties proportionally
          const scaledSwapoParties = swapoParties.map((p) => ({
            ...p,
            percentage: p.percentage * renormalizeFactor,
          }));
          const scaledOppositionParties = oppositionParties.map((p) => ({
            ...p,
            percentage:
              (p.percentage + (5 * p.percentage) / oppositionPercentage) *
              renormalizeFactor,
          }));

          // Combine and find new winner
          const allParties = [
            ...scaledSwapoParties,
            ...scaledOppositionParties,
          ].sort((a, b) => b.percentage - a.percentage);

          const newWinner = allParties[0];
          const newRunnerUp = allParties[1] || { percentage: 0 };
          const newMargin = newWinner.percentage - newRunnerUp.percentage;

          const newIsSWAPO = isSWAPOParty(newWinner);
          const originalIsSWAPO =
            baselineResults.find(
              (r) => r.constituency.name === constituency.name
            )?.isSWAPO || false;
          const flipped = originalIsSWAPO && !newIsSWAPO;

          return {
            constituency,
            isSWAPO: newIsSWAPO,
            margin: newMargin,
            flipped,
            winnerName: newIsSWAPO ? "SWAPO" : "Opposition",
            isTarget: true,
          };
        });

        const turnoutSwapoSeats = turnoutResults.filter(
          (r) => r.isSWAPO
        ).length;
        const turnoutOppositionSeats = turnoutResults.filter(
          (r) => !r.isSWAPO
        ).length;
        const turnoutAvgMargin =
          turnoutResults.reduce((sum, r) => sum + r.margin, 0) /
          turnoutResults.length;
        const turnoutFlips = turnoutResults.filter((r) => r.flipped).length;

        // Render KPI cards (showing baseline)
        const kpisContainer = document.getElementById("scenarios-kpis");
        kpisContainer.innerHTML = `
          <div class="stat-card">
            <div class="stat-label">2019 SWAPO seats</div>
            <div class="stat-number">${baselineSwapoSeats}</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">2019 Opposition seats</div>
            <div class="stat-number">${baselineOppositionSeats}</div>
          </div>
          <div class="stat-card">
            <div class="stat-label">Avg margin (2019)</div>
            <div class="stat-number">${baselineAvgMargin.toFixed(1)}%</div>
          </div>
        `;

        // Render all three scenario cards
        const bounds = getNamibiaBounds(constituencies2019);
        const cardsContainer = document.getElementById("scenarios-cards");
        cardsContainer.style.gridTemplateColumns = "repeat(3, 1fr)";
        cardsContainer.innerHTML = `
          <div class="comparison-box">
            <h4>Baseline 2019</h4>
            <div style="text-align: center; margin-bottom: 15px;">
              <div style="display: inline-block; padding: 10px 20px; background: rgba(231, 76, 60, 0.2); border-radius: 8px; border: 1px solid rgba(231, 76, 60, 0.4);">
                <span style="color: #E74C3C; font-weight: 700; font-size: 1.1em;">${baselineSwapoSeats}</span>
                <span style="color: rgba(255, 255, 255, 0.9); font-size: 0.9em; margin-left: 5px;">SWAPO seats</span>
              </div>
            </div>
            <div id="scenarios-baseline-map" style="height: 400px; border-radius: 12px; overflow: hidden; margin-top: 20px; border: 2px solid rgba(255,255,255,0.1); box-shadow: 0 4px 12px rgba(0,0,0,0.3);"></div>
            <p style="text-align: center; margin-top: 15px; color: rgba(255, 255, 255, 0.8); font-size: 0.95em; font-weight: 500;">Baseline scenario (actual 2019 results)</p>
          </div>
          <div class="comparison-box">
            <h4>Coalition N=2 (2019)</h4>
            <div style="text-align: center; margin-bottom: 15px;">
              <div style="display: inline-block; padding: 10px 20px; background: rgba(39, 174, 96, 0.2); border-radius: 8px; border: 1px solid rgba(39, 174, 96, 0.4);">
                <span style="color: #27AE60; font-weight: 700; font-size: 1.1em;">${coalitionOppositionSeats}</span>
                <span style="color: rgba(255, 255, 255, 0.9); font-size: 0.9em; margin-left: 5px;">Opposition seats</span>
              </div>
            </div>
            <div id="scenarios-coalition-map" style="height: 400px; border-radius: 12px; overflow: hidden; margin-top: 20px; border: 2px solid rgba(255,255,255,0.1); box-shadow: 0 4px 12px rgba(0,0,0,0.3);"></div>
            <p style="text-align: center; margin-top: 15px; color: #27AE60; font-size: 0.95em; font-weight: 600;">+${coalitionFlips} constituency flips vs baseline</p>
          </div>
          <div class="comparison-box">
            <h4>Turnout +5pp (targets only)</h4>
            <div style="text-align: center; margin-bottom: 15px;">
              <div style="display: inline-block; padding: 10px 20px; background: rgba(52, 152, 219, 0.2); border-radius: 8px; border: 1px solid rgba(52, 152, 219, 0.4);">
                <span style="color: #3498DB; font-weight: 700; font-size: 1.1em;">${turnoutOppositionSeats}</span>
                <span style="color: rgba(255, 255, 255, 0.9); font-size: 0.9em; margin-left: 5px;">Opposition seats</span>
              </div>
            </div>
            <div id="scenarios-turnout-map" style="height: 400px; border-radius: 12px; overflow: hidden; margin-top: 20px; border: 2px solid rgba(255,255,255,0.1); box-shadow: 0 4px 12px rgba(0,0,0,0.3);"></div>
            <p style="text-align: center; margin-top: 15px; color: #3498DB; font-size: 0.95em; font-weight: 600;">+${turnoutFlips} constituency flips vs baseline</p>
          </div>
        `;

        // Create Baseline map
        createMiniMap(
          "scenarios-baseline-map",
          baselineResults.map((r) => ({
            constituency: r.constituency,
            result: r,
          })),
          (item) =>
            item.result.isSWAPO
              ? partyColors["SWAPO"]
              : partyColors["Opposition"],
          (item) => `
            <div>
              <strong>${item.constituency.name}</strong><br>
              <span class="tooltip-label">Winner:</span> ${
                item.result.winnerName
              }<br>
              <span class="tooltip-label">Margin:</span> ${item.result.margin.toFixed(
                1
              )}%
            </div>
          `,
          bounds
        );

        // Create Coalition map
        createMiniMap(
          "scenarios-coalition-map",
          coalitionResults.map((r) => ({
            constituency: r.constituency,
            result: r,
          })),
          (item) => {
            if (item.result.isSWAPO) {
              return item.result.margin < 5
                ? partyColors["Competitive"]
                : partyColors["SWAPO"];
            } else {
              return partyColors["Coordinated"] || "#27AE60";
            }
          },
          (item) => `
            <div>
              <strong>${item.constituency.name}</strong><br>
              <span class="tooltip-label">Winner:</span> ${
                item.result.winnerName
              }<br>
              <span class="tooltip-label">Margin:</span> ${item.result.margin.toFixed(
                1
              )}%<br>
              ${
                item.result.flipped
                  ? '<span style="color: #27AE60; font-weight: 600;">FLIPPED</span>'
                  : ""
              }
            </div>
          `,
          bounds
        );

        // Create Turnout map
        createMiniMap(
          "scenarios-turnout-map",
          turnoutResults.map((r) => ({
            constituency: r.constituency,
            result: r,
          })),
          (item) => {
            if (!item.result.isTarget) {
              // Not a target - show baseline result
              return item.result.isSWAPO
                ? partyColors["SWAPO"]
                : partyColors["Opposition"];
            } else {
              // Target with turnout boost
              return item.result.isSWAPO
                ? partyColors["SWAPO"]
                : partyColors["Opposition"];
            }
          },
          (item) => `
            <div>
              <strong>${item.constituency.name}</strong><br>
              <span class="tooltip-label">Winner:</span> ${
                item.result.winnerName
              }<br>
              <span class="tooltip-label">Margin:</span> ${item.result.margin.toFixed(
                1
              )}%<br>
              ${
                item.result.isTarget
                  ? '<span class="tooltip-label">Target:</span> Yes'
                  : '<span class="tooltip-label">Target:</span> No'
              }<br>
              ${
                item.result.flipped
                  ? '<span style="color: #27AE60; font-weight: 600;">FLIPPED</span>'
                  : ""
              }
            </div>
          `,
          bounds
        );
      }

      function createRegionalTreemap() {
        const yearSelect = document.getElementById("treemap-year");
        const selectedYear = yearSelect ? parseInt(yearSelect.value) : 2019;
        const constituencies = getByYear(selectedYear);

        if (!constituencies || constituencies.length === 0) {
          const container = document.getElementById("treemap-chart");
          d3.select(container).selectAll("*").remove();
          container.innerHTML = `<p style="text-align: center; color: #f5f5dc; padding: 40px;">No data available for ${selectedYear}</p>`;
          return;
        }

        // Aggregate data by region and party_abbr, summing percentages
        const regionPartyMap = new Map();

        constituencies.forEach((constituency) => {
          const region = constituency.region;
          if (!region) return;

          // Handle cases where parties array might be missing or empty
          if (!constituency.parties || constituency.parties.length === 0) {
            return;
          }

          constituency.parties.forEach((party) => {
            // Skip if party data is incomplete
            if (!party.abbr || !party.percentage) return;

            // Normalize SWAPO variants to "SWAPO"
            const normalizedParty = normalizeParty(party);

            const key = `${region}|${normalizedParty.abbr}`;
            if (!regionPartyMap.has(key)) {
              regionPartyMap.set(key, {
                region: region,
                partyAbbr: normalizedParty.abbr,
                partyName: normalizedParty.name,
                percentage: 0,
              });
            }
            const entry = regionPartyMap.get(key);
            entry.percentage += party.percentage;
          });
        });

        // Group by region
        const regionGroups = new Map();
        regionPartyMap.forEach((entry) => {
          if (!regionGroups.has(entry.region)) {
            regionGroups.set(entry.region, []);
          }
          regionGroups.get(entry.region).push(entry);
        });

        // Build hierarchical structure for D3 treemap
        const treemapData = {
          name: "root",
          children: Array.from(regionGroups.entries()).map(
            ([region, parties]) => ({
              name: region,
              region: region,
              children: parties.map((p) => ({
                name: p.partyAbbr,
                region: p.region,
                partyAbbr: p.partyAbbr,
                partyName: p.partyName,
                value: p.percentage,
                percentage: p.percentage,
              })),
            })
          ),
        };

        // Calculate total percentage for each region and normalize party percentages
        treemapData.children.forEach((regionNode) => {
          const regionTotal = regionNode.children.reduce(
            (sum, p) => sum + p.value,
            0
          );
          regionNode.value = regionTotal;
          // Normalize party percentages to sum to 100% per region for display
          regionNode.children.forEach((partyNode) => {
            partyNode.normalizedPercentage =
              regionTotal > 0 ? (partyNode.value / regionTotal) * 100 : 0;
          });
        });

        // Clear previous treemap
        const container = document.getElementById("treemap-chart");
        d3.select(container).selectAll("*").remove();

        // Set up dimensions - ensure we get accurate container width and height
        const margin = { top: 10, right: 30, bottom: 10, left: 10 };
        // Force container to be block-level and full-width
        container.style.display = "flex";
        container.style.width = "100%";
        container.style.alignItems = "center";
        container.style.justifyContent = "center";
        // Get the actual computed dimensions of the container
        const containerRect = container.getBoundingClientRect();
        const containerWidth =
          containerRect.width || container.offsetWidth || 900;
        // For height, use viewport height minus header elements for more accurate sizing
        const headerHeight = 280; // Approximate height of title, subtitle, takeaway, year selector
        const navHeight = 120; // Navigation and keyboard hints
        const viewportHeight = window.innerHeight;
        const availableHeight = viewportHeight - headerHeight - navHeight;
        const containerHeight = Math.max(
          containerRect.height || container.offsetHeight || availableHeight,
          availableHeight
        );
        const width = Math.max(
          containerWidth - margin.left - margin.right - 60,
          350
        ); // Subtract extra padding for labels, minimum 600px
        // Use container height dynamically - fill the available space
        const height = Math.max(
          Math.min(
            containerHeight - margin.top - margin.bottom - 30,
            availableHeight
          ),
          300
        );

        // Create SVG
        const svg = d3
          .select(container)
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);

        const g = svg
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Create tooltip
        let tooltip = d3.select(".d3-tooltip-treemap");
        if (tooltip.empty()) {
          tooltip = d3
            .select("body")
            .append("div")
            .attr("class", "d3-tooltip d3-tooltip-treemap")
            .style("opacity", 0)
            .style("position", "fixed")
            .style(
              "background",
              "linear-gradient(135deg, rgba(26, 31, 58, 0.98) 0%, rgba(37, 43, 74, 0.98) 100%)"
            )
            .style("color", "#ffffff")
            .style("padding", "16px")
            .style("border-radius", "10px")
            .style("pointer-events", "none")
            .style("font-size", "13px")
            .style("z-index", "10000")
            .style("max-width", "350px")
            .style("min-width", "280px")
            .style("border", "2px solid rgba(90, 103, 216, 0.4)")
            .style("box-shadow", "0 8px 24px rgba(0, 0, 0, 0.6)")
            .style("backdrop-filter", "blur(10px)");
        }

        // Create treemap layout
        const root = d3
          .hierarchy(treemapData)
          .sum((d) => d.value)
          .sort((a, b) => b.value - a.value);

        d3
          .treemap()
          .size([width, height])
          .paddingInner(2)
          .paddingTop(25)
          .tile(d3.treemapSliceDice)(root);

        // Track filtered region (use a persistent variable outside function scope)
        if (typeof window.treemapFilteredRegion === "undefined") {
          window.treemapFilteredRegion = null;
        }
        let filteredRegion = window.treemapFilteredRegion;

        // Draw region groups (parent nodes)
        const regions = g
          .selectAll(".region-group")
          .data(root.children)
          .enter()
          .append("g")
          .attr("class", "region-group");

        // Draw party tiles
        const tiles = regions
          .selectAll(".tile")
          .data((d) => d.children)
          .enter()
          .append("rect")
          .attr("class", "tile")
          .attr("x", (d) => d.x0)
          .attr("y", (d) => d.y0)
          .attr("width", (d) => d.x1 - d.x0)
          .attr("height", (d) => d.y1 - d.y0)
          .attr("fill", (d) => {
            // Check if it's SWAPO (using normalized abbreviation)
            if (d.data.partyAbbr === "SWAPO") {
              return partyColors["SWAPO"] || "#E74C3C";
            }
            // Try party-specific color first, then fallback to Opposition color, then neutral gray
            return (
              partyColors[d.data.partyAbbr] ||
              partyColors["Opposition"] ||
              "#95A5A6"
            ); // Neutral fallback color
          })
          .attr("stroke", "#fff")
          .attr("stroke-width", 1)
          .style("cursor", "pointer")
          .on("mouseover", function (event, d) {
            d3.select(this).attr("stroke-width", 2).attr("stroke", "#fff");

            tooltip.transition().duration(200).style("opacity", 1);

            // Ensure we never display the long SWAPO name
            const displayPartyName = isSWAPOParty({
              name: d.data.partyName,
              abbr: d.data.partyAbbr,
            })
              ? "SWAPO"
              : d.data.partyName || d.data.partyAbbr;

            // Calculate detailed statistics for this party in this region
            const regionConstituencies = constituencies.filter(
              (c) => c.region === d.data.region
            );
            const partyAbbr = d.data.partyAbbr;
            const isSWAPO = isSWAPOParty({
              name: d.data.partyName,
              abbr: partyAbbr,
            });

            // Find all constituencies where this party competed
            const partyConstituencies = regionConstituencies
              .map((c) => {
                const partyData = c.parties.find((p) => {
                  const normalized = normalizeParty(p);
                  return normalized.abbr === partyAbbr;
                });
                return partyData
                  ? {
                      constituency: c.name,
                      percentage: partyData.percentage,
                      isWinner:
                        c.winner && normalizeParty(c.winner).abbr === partyAbbr,
                      isRunnerUp:
                        c.runnerUp &&
                        normalizeParty(c.runnerUp).abbr === partyAbbr,
                      margin: c.winner
                        ? c.winner.percentage - c.runnerUp.percentage
                        : 0,
                    }
                  : null;
              })
              .filter((x) => x !== null);

            // Calculate statistics
            const totalConstituencies = regionConstituencies.length;
            const constituenciesCompeted = partyConstituencies.length;
            const constituenciesWon = partyConstituencies.filter(
              (p) => p.isWinner
            ).length;
            const constituenciesRunnerUp = partyConstituencies.filter(
              (p) => p.isRunnerUp
            ).length;
            const avgVoteShare =
              partyConstituencies.length > 0
                ? partyConstituencies.reduce(
                    (sum, p) => sum + p.percentage,
                    0
                  ) / partyConstituencies.length
                : 0;
            const bestConstituency =
              partyConstituencies.length > 0
                ? partyConstituencies.reduce((best, curr) =>
                    curr.percentage > best.percentage ? curr : best
                  )
                : null;
            const worstConstituency =
              partyConstituencies.length > 0
                ? partyConstituencies.reduce((worst, curr) =>
                    curr.percentage < worst.percentage ? curr : worst
                  )
                : null;

            // Calculate rank in region (by total vote share)
            const allPartiesInRegion = Array.from(regionPartyMap.values())
              .filter((p) => p.region === d.data.region)
              .sort((a, b) => b.percentage - a.percentage);
            const partyRank =
              allPartiesInRegion.findIndex((p) => p.partyAbbr === partyAbbr) +
              1;
            const totalPartiesInRegion = allPartiesInRegion.length;

            // Calculate vote share relative to SWAPO
            const swapoData = allPartiesInRegion.find((p) =>
              isSWAPOParty({ abbr: p.partyAbbr })
            );
            const swapoShare = swapoData ? swapoData.percentage : 0;
            const relativeToSWAPO =
              swapoShare > 0
                ? ((d.data.percentage / swapoShare) * 100).toFixed(1)
                : "N/A";

            // Calculate coverage (percentage of constituencies where party competed)
            const coverage =
              totalConstituencies > 0
                ? (
                    (constituenciesCompeted / totalConstituencies) *
                    100
                  ).toFixed(1)
                : 0;

            // Calculate win rate
            const winRate =
              constituenciesCompeted > 0
                ? ((constituenciesWon / constituenciesCompeted) * 100).toFixed(
                    1
                  )
                : 0;

            // Find constituencies where party was competitive (within 5% of winner)
            const competitiveConstituencies = partyConstituencies.filter(
              (p) => {
                if (!p.isWinner) {
                  // Find the winner's percentage for this constituency
                  const constituency = regionConstituencies.find(
                    (c) => c.name === p.constituency
                  );
                  if (constituency && constituency.winner) {
                    const margin =
                      constituency.winner.percentage - p.percentage;
                    return margin <= 5;
                  }
                }
                return false;
              }
            ).length;

            // Calculate if party is above or below regional average
            const regionalAvg =
              allPartiesInRegion.length > 0
                ? allPartiesInRegion.reduce((sum, p) => sum + p.percentage, 0) /
                  allPartiesInRegion.length
                : 0;
            const vsRegionalAvg = d.data.percentage - regionalAvg;

            // Build comprehensive tooltip
            let tooltipContent = `
              <div style="line-height: 1.6;">
                <div style="font-size: 16px; font-weight: 700; color: #ffffff; margin-bottom: 8px; border-bottom: 2px solid rgba(255,255,255,0.3); padding-bottom: 6px;">
                  ${displayPartyName}
                </div>
                <div style="font-size: 13px; color: #a8b3ff; margin-bottom: 10px; font-weight: 600;">
                  ${d.data.region} Region • ${selectedYear} Election
                </div>
                
                <div style="background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px; margin-bottom: 8px;">
                  <div style="font-size: 18px; font-weight: 700; color: #5a67d8;">
                    ${
                      d.normalizedPercentage
                        ? d.normalizedPercentage.toFixed(1)
                        : d.data.percentage.toFixed(1)
                    }%
                  </div>
                  <div style="font-size: 11px; color: #bdc3c7; margin-top: 2px;">
                    Total Vote Share in Region
                  </div>
                </div>
                
                <div style="margin-top: 10px; font-size: 12px;">
                  <div style="margin-bottom: 6px;">
                    <span style="color: #85c1e9; font-weight: 600;">Rank:</span> 
                    <span style="color: #ffffff;">${partyRank}${
              partyRank === 1
                ? "st"
                : partyRank === 2
                ? "nd"
                : partyRank === 3
                ? "rd"
                : "th"
            } of ${totalPartiesInRegion} parties</span>
                  </div>
                  <div style="margin-bottom: 6px;">
                    <span style="color: #85c1e9; font-weight: 600;">Constituencies:</span> 
                    <span style="color: #ffffff;">Competed in ${constituenciesCompeted} of ${totalConstituencies} (${coverage}% coverage)</span>
                  </div>
                  <div style="margin-bottom: 6px;">
                    <span style="color: #85c1e9; font-weight: 600;">Wins:</span> 
                    <span style="color: #7dcea0; font-weight: 600;">${constituenciesWon} constituency${
              constituenciesWon !== 1 ? "ies" : "y"
            }</span>
                    ${
                      constituenciesRunnerUp > 0
                        ? `<span style="color: #f5b041; margin-left: 8px;">(${constituenciesRunnerUp} runner-up${
                            constituenciesRunnerUp !== 1 ? "s" : ""
                          })</span>`
                        : ""
                    }
                  </div>
                  <div style="margin-bottom: 6px;">
                    <span style="color: #85c1e9; font-weight: 600;">Average Vote Share:</span> 
                    <span style="color: #ffffff;">${avgVoteShare.toFixed(
                      1
                    )}%</span>
                    <span style="color: #95a5a6; font-size: 11px; margin-left: 4px;">(where competed)</span>
                  </div>
                  <div style="margin-bottom: 6px;">
                    <span style="color: #85c1e9; font-weight: 600;">Win Rate:</span> 
                    <span style="color: ${
                      constituenciesWon > 0 ? "#7dcea0" : "#95a5a6"
                    }; font-weight: 600;">${winRate}%</span>
                    <span style="color: #95a5a6; font-size: 11px; margin-left: 4px;">(${constituenciesWon}/${constituenciesCompeted} constituencies)</span>
                  </div>
                  ${
                    competitiveConstituencies > 0
                      ? `
                  <div style="margin-bottom: 6px;">
                    <span style="color: #85c1e9; font-weight: 600;">Competitive Races:</span> 
                    <span style="color: #f5b041; font-weight: 600;">${competitiveConstituencies} within 5% of winning</span>
                  </div>
                  `
                      : ""
                  }
                  ${
                    vsRegionalAvg !== 0
                      ? `
                  <div style="margin-bottom: 6px;">
                    <span style="color: #85c1e9; font-weight: 600;">Regional Standing:</span> 
                    <span style="color: ${
                      vsRegionalAvg > 0 ? "#7dcea0" : "#ec7063"
                    }; font-weight: 600;">
                      ${vsRegionalAvg > 0 ? "+" : ""}${vsRegionalAvg.toFixed(
                          1
                        )}%
                    </span>
                    <span style="color: #95a5a6; font-size: 11px; margin-left: 4px;">vs regional average</span>
                  </div>
                  `
                      : ""
                  }
            `;

            if (bestConstituency) {
              tooltipContent += `
                  <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div style="color: #7dcea0; font-weight: 600; font-size: 11px; margin-bottom: 4px;">BEST PERFORMANCE</div>
                    <div style="font-size: 12px;">
                      <span style="color: #ffffff; font-weight: 600;">${
                        bestConstituency.constituency
                      }</span>
                      <span style="color: #7dcea0; margin-left: 6px;">${bestConstituency.percentage.toFixed(
                        1
                      )}%</span>
                      ${
                        bestConstituency.isWinner
                          ? '<span style="color: #27AE60; margin-left: 6px; font-weight: 600;">✓ Winner</span>'
                          : ""
                      }
                      ${
                        bestConstituency.isRunnerUp
                          ? '<span style="color: #F39C12; margin-left: 6px; font-weight: 600;">2nd Place</span>'
                          : ""
                      }
                    </div>
                  </div>
              `;
            }

            if (
              worstConstituency &&
              worstConstituency.constituency !==
                bestConstituency?.constituency &&
              constituenciesCompeted > 1
            ) {
              tooltipContent += `
                  <div style="margin-top: 6px; padding-top: 6px; border-top: 1px solid rgba(255,255,255,0.05);">
                    <div style="color: #95a5a6; font-weight: 600; font-size: 10px; margin-bottom: 3px;">LOWEST PERFORMANCE</div>
                    <div style="font-size: 11px; color: #bdc3c7;">
                      <span>${worstConstituency.constituency}</span>
                      <span style="color: #95a5a6; margin-left: 6px;">${worstConstituency.percentage.toFixed(
                        1
                      )}%</span>
                    </div>
                  </div>
              `;
            }

            if (!isSWAPO && swapoShare > 0) {
              tooltipContent += `
                  <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div style="color: #ec7063; font-weight: 600; font-size: 11px; margin-bottom: 4px;">VS SWAPO</div>
                    <div style="font-size: 12px;">
                      <span style="color: #ffffff;">${relativeToSWAPO}% of SWAPO's vote share</span>
                      <div style="color: #95a5a6; font-size: 11px; margin-top: 2px;">
                        SWAPO: ${swapoShare.toFixed(
                          1
                        )}% | ${displayPartyName}: ${d.data.percentage.toFixed(
                1
              )}%
                      </div>
                    </div>
                  </div>
              `;
            }

            if (isSWAPO) {
              tooltipContent += `
                  <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                    <div style="color: #ec7063; font-weight: 600; font-size: 11px; margin-bottom: 4px;">DOMINANCE</div>
                    <div style="font-size: 12px; color: #ffffff;">
                      ${
                        constituenciesWon === totalConstituencies
                          ? "Won all constituencies in this region"
                          : `Won ${constituenciesWon} of ${totalConstituencies} constituencies`
                      }
                    </div>
                  </div>
              `;
            }

            // Add click to learn more prompt
            tooltipContent += `
                  <div style="margin-top: 10px; padding-top: 10px; border-top: 2px solid rgba(90, 103, 216, 0.5);">
                    <div style="font-size: 11px; color: #a8b3ff; font-style: italic; text-align: center;">
                      <strong>Click</strong> this tile or the region label to filter the electoral map above and explore ${d.data.region}'s constituencies in detail
                    </div>
                  </div>
            `;

            tooltipContent += `
                </div>
              </div>
            `;

            tooltip.html(tooltipContent);

            // Smart positioning to prevent cutoff
            const tooltipNode = tooltip.node();
            const tooltipRect = tooltipNode.getBoundingClientRect();
            const tooltipWidth = tooltipRect.width || 350;
            const tooltipHeight = tooltipRect.height || 200;

            let left = event.clientX + 15;
            let top = event.clientY - 10;

            // Prevent right edge cutoff
            if (left + tooltipWidth > window.innerWidth - 10) {
              left = event.clientX - tooltipWidth - 15;
            }

            // Prevent bottom edge cutoff
            if (top + tooltipHeight > window.innerHeight - 10) {
              top = window.innerHeight - tooltipHeight - 10;
            }

            // Prevent top edge cutoff
            if (top < 10) {
              top = 10;
            }

            // Prevent left edge cutoff
            if (left < 10) {
              left = 10;
            }

            tooltip.style("left", left + "px").style("top", top + "px");
          })
          .on("mouseout", function () {
            d3.select(this).attr("stroke-width", 1);

            tooltip.transition().duration(200).style("opacity", 0);
          })
          .on("click", function (event, d) {
            event.stopPropagation();
            const region = d.data.region;

            if (filteredRegion === region) {
              // Clear filter
              clearRegionFilter();
            } else {
              // Apply filter
              filterMap1ByRegion(region);
              window.treemapFilteredRegion = region;
              filteredRegion = region;
              const clearBtn = document.getElementById("clear-treemap-filter");
              if (clearBtn) clearBtn.style.display = "inline-block";
            }
          });

        // Create defs for clipping paths
        let defs = svg.select("defs");
        if (defs.empty()) {
          defs = svg.append("defs");
        }

        // Collect all tiles and create clipPaths
        let clipCounter = 0;
        const allTiles = [];
        root.children.forEach((region) => {
          region.children.forEach((tile) => {
            tile.clipId = `clip-treemap-${clipCounter++}`;
            allTiles.push(tile);
          });
        });

        // Create clipPaths for each tile
        const clips = defs
          .selectAll(".tile-clip")
          .data(allTiles)
          .enter()
          .append("clipPath")
          .attr("class", "tile-clip")
          .attr("id", (d) => d.clipId);

        clips
          .append("rect")
          .attr("x", (d) => d.x0)
          .attr("y", (d) => d.y0)
          .attr("width", (d) => d.x1 - d.x0)
          .attr("height", (d) => d.y1 - d.y0);

        // Add labels to tiles (if large enough) with clipping
        const labels = regions
          .selectAll(".label")
          .data((d) =>
            d.children.filter(
              (child) => child.x1 - child.x0 > 60 && child.y1 - child.y0 > 30
            )
          )
          .enter()
          .append("text")
          .attr("class", "label")
          .attr("clip-path", (d) => `url(#${d.clipId})`)
          .attr("x", (d) => d.x0 + (d.x1 - d.x0) / 2)
          .attr("y", (d) => d.y0 + (d.y1 - d.y0) / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", "middle")
          .attr("fill", "#ffffff")
          .attr("font-size", "12px")
          .attr("font-weight", "600")
          .style("pointer-events", "none")
          .text((d) => d.data.partyAbbr);

        // Helper function to calculate text width for word wrapping
        function getTextWidth(text, fontSize, fontWeight) {
          const canvas = document.createElement("canvas");
          const context = canvas.getContext("2d");
          context.font = `${fontWeight} ${fontSize}`;
          return context.measureText(text).width;
        }

        // Apply word wrapping to prevent text overflow
        labels.each(function (d) {
          const text = d3.select(this);
          const tileWidth = d.x1 - d.x0;
          const tileHeight = d.y1 - d.y0;
          const maxWidth = tileWidth * 0.85; // Leave 15% margin on each side
          const lineHeight = 14;
          const maxLines = Math.floor((tileHeight * 0.8) / lineHeight); // Use 80% of height

          const labelText = d.data.partyAbbr;
          const textWidth = getTextWidth(labelText, "12px", "600");

          // If text fits in one line, keep it simple
          if (textWidth <= maxWidth || maxLines < 1) {
            text.text(labelText);
            return;
          }

          // Split into words and wrap
          const words = labelText.split(/\s+/);
          let line = "";
          let lineNumber = 0;
          const lines = [];

          words.forEach((word) => {
            const testLine = line + (line ? " " : "") + word;
            const testWidth = getTextWidth(testLine, "12px", "600");
            if (testWidth > maxWidth && line) {
              lines.push(line);
              line = word;
              lineNumber++;
              if (lineNumber >= maxLines) {
                // Truncate if too many lines
                line = line.length > 10 ? line.substring(0, 10) + "..." : line;
                return;
              }
            } else {
              line = testLine;
            }
          });
          if (line && lineNumber < maxLines) {
            lines.push(line);
          }

          // Update text with wrapped lines
          text.text(null);
          lines.forEach((lineText, i) => {
            text
              .append("tspan")
              .attr("x", d.x0 + (d.x1 - d.x0) / 2)
              .attr("y", d.y0 + (d.y1 - d.y0) / 2)
              .attr(
                "dy",
                i === 0
                  ? `${(-(lines.length - 1) * lineHeight) / 2}px`
                  : `${lineHeight}px`
              )
              .attr("text-anchor", "middle")
              .text(lineText);
          });
        });

        // Create clipPaths for region labels
        const regionClips = defs
          .selectAll(".region-clip")
          .data(root.children)
          .enter()
          .append("clipPath")
          .attr("class", "region-clip")
          .attr("id", (d, i) => `clip-region-${i}`);

        regionClips
          .append("rect")
          .attr("x", (d) => d.x0)
          .attr("y", (d) => d.y0)
          .attr("width", (d) => d.x1 - d.x0)
          .attr("height", 25); // Clip to top 25px for region labels

        // Add region group labels (clickable) with clipping
        const regionLabels = regions
          .append("text")
          .attr("class", "region-label")
          .attr("clip-path", (d, i) => `url(#clip-region-${i})`)
          .attr("x", (d) => d.x0 + 5)
          .attr("y", (d) => d.y0 + 18)
          .attr("fill", "#ffffff")
          .attr("font-size", "13px")
          .attr("font-weight", "700")
          .style("cursor", "pointer")
          .text((d) => {
            // Use abbreviations for longer region names
            const regionAbbreviations = {
              Ohangwena: "Ohang.",
              Otjozondjupa: "Otjoz.",
              "Kavango East": "Kav.E",
              "Kavango West": "Kav.W",
              Omaheke: "Omah.",
              Kunene: "Kun.",
              Erongo: "Eron.",
              Hardap: "Hard.",
              "||Karas": "||Kar.",
              Zambezi: "Zamb.",
            };

            const regionName = d.data.name;
            const regionWidth = d.x1 - d.x0;
            const maxWidth = regionWidth - 6;

            // Try abbreviated name first if available
            const displayName = regionAbbreviations[regionName] || regionName;
            const textWidth = getTextWidth(displayName, "13px", "700");

            if (textWidth > maxWidth) {
              // If still too long, truncate further
              let truncated = displayName;
              while (
                getTextWidth(truncated, "13px", "700") > maxWidth &&
                truncated.length > 2
              ) {
                truncated = truncated.substring(0, truncated.length - 1);
              }
              return truncated;
            }
            return displayName;
          })
          .on("click", function (event, d) {
            event.stopPropagation();
            const region = d.data.region;

            if (filteredRegion === region) {
              clearRegionFilter();
            } else {
              filterMap1ByRegion(region);
              window.treemapFilteredRegion = region;
              filteredRegion = region;
              const clearBtn = document.getElementById("clear-treemap-filter");
              if (clearBtn) clearBtn.style.display = "inline-block";
            }
          });

        // Function to filter Map 1
        function filterMap1ByRegion(region) {
          if (window.map1Instance && window.map1Instance.filterRegion) {
            window.map1Instance.filterRegion(region);
          }
        }

        // Function to clear filter
        function clearRegionFilter() {
          window.treemapFilteredRegion = null;
          filteredRegion = null;
          const clearButton = document.getElementById("clear-treemap-filter");
          if (clearButton) {
            clearButton.style.display = "none";
          }
          if (window.map1Instance && window.map1Instance.filterRegion) {
            window.map1Instance.filterRegion(null);
          }
        }

        // Add Clear filter button if it doesn't exist
        const treemapSection = container.parentElement;
        let clearButton = document.getElementById("clear-treemap-filter");
        if (!clearButton && treemapSection) {
          // Create a wrapper div for the button (similar to ENP heatmap)
          const buttonWrapper = document.createElement("div");
          buttonWrapper.style.cssText = "margin: 10px 0; text-align: center;";
          clearButton = document.createElement("button");
          clearButton.id = "clear-treemap-filter";
          clearButton.textContent = "Clear Filter";
          clearButton.style.cssText =
            "padding: 8px 16px; background: rgba(26, 31, 58, 0.8); color: #ffffff; border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; cursor: pointer; display: none;";
          buttonWrapper.appendChild(clearButton);
          // Insert before the chart container
          treemapSection.insertBefore(buttonWrapper, container);
          clearButton.addEventListener("click", clearRegionFilter);
        } else if (clearButton) {
          // Button exists, just ensure event listener is attached (remove old, add new)
          const newButton = clearButton.cloneNode(true);
          clearButton.parentNode.replaceChild(newButton, clearButton);
          document
            .getElementById("clear-treemap-filter")
            .addEventListener("click", clearRegionFilter);
        }

        if (yearSelect) {
          if (!window.treemapYearHandler) {
            window.treemapYearHandler = function () {
              if (window.treemapFilteredRegion !== null) {
                if (window.map1Instance && window.map1Instance.filterRegion) {
                  window.map1Instance.filterRegion(null);
                }
                window.treemapFilteredRegion = null;
                const clearBtn = document.getElementById(
                  "clear-treemap-filter"
                );
                if (clearBtn) clearBtn.style.display = "none";
              }
              createRegionalTreemap();
            };
          }
          yearSelect.removeEventListener("change", window.treemapYearHandler);
          yearSelect.addEventListener("change", window.treemapYearHandler);
        }
      }

      function initializeVisualizations() {
        createMap1();
        createMap3();
        createMap4();
        createClosestRacesChart();
        createTargetConstituencies();
        createUrbanAnalysis();
        createTurnoutAnalysis();
        createShiftMap();
        createCoalitionMap();
        createMarginBeeswarm();
        createENPHeatmap();
        createScenariosDashboard();
        createRegionalTreemap();

        // Update stats with retry mechanism to ensure data is loaded
        updateStats();
        setTimeout(() => updateStats(), 500);
        setTimeout(() => updateStats(), 1000);
        setTimeout(() => updateStats(), 2000);

        // Set up treemap year selector
        setupTreemapYearSelector();
      }

      function setupTreemapYearSelector() {
        const yearSelect = document.getElementById("treemap-year");
        if (yearSelect) {
          yearSelect.onchange = function () {
            if (window.treemapFilteredRegion !== null) {
              if (window.map1Instance && window.map1Instance.filterRegion) {
                window.map1Instance.filterRegion(null);
              }
              window.treemapFilteredRegion = null;
              const clearBtn = document.getElementById("clear-treemap-filter");
              if (clearBtn) clearBtn.style.display = "none";
            }
            createRegionalTreemap();
          };
        }
        setupTreemapResize();
      }

      let treemapResizeTimeout;
      (function setupTreemapResizeOnce() {
        window.addEventListener("resize", function () {
          const treemapSvg = document.querySelector("#treemap-chart svg");
          if (treemapSvg) {
            clearTimeout(treemapResizeTimeout);
            treemapResizeTimeout = setTimeout(function () {
              if (typeof createRegionalTreemap === "function") {
                createRegionalTreemap();
              }
            }, 200);
          }
        });
      })();

      // Kept for compatibility
      function setupTreemapResize() {
        // Resize handler is now installed globally above
      }

      // Simple debounce helper for resize events
      function debounce(fn, delay) {
        let t;
        return function () {
          clearTimeout(t);
          const ctx = this;
          const args = arguments;
          t = setTimeout(function () {
            fn.apply(ctx, args);
          }, delay);
        };
      }

      function createMap1() {
        removeExistingMap("map1");

        const constituencies2019 = Object.values(processedData).filter(
          (c) => c.year === 2019
        );
        const bounds = getNamibiaBounds(constituencies2019);
        const map = L.map("map1", {
          attributionControl: false,
          worldCopyJump: false,
        });
        map.fitBounds(bounds);
        map.setMaxBounds(bounds.pad(0.1));

        // Add tile layer with normal/light theme
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "",
          maxZoom: 19,
        }).addTo(map);

        // Toggle button functionality
        const mapContainer = document.getElementById("map1");
        const toggleButton = document.getElementById("map1-toggle");
        let isWhiteBackground = false;

        toggleButton.addEventListener("click", function () {
          isWhiteBackground = !isWhiteBackground;
          if (isWhiteBackground) {
            mapContainer.classList.add("white-bg");
            map.eachLayer(function (layer) {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            // No tile layer - just white background
            toggleButton.textContent = "Show Map Background";
          } else {
            mapContainer.classList.remove("white-bg");
            map.eachLayer(function (layer) {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
              attribution: "",
              maxZoom: 19,
            }).addTo(map);
            toggleButton.textContent = "Show White Background";
          }
        });

        // Store polygon layers for filtering and highlighting
        const polygonLayers = [];
        const constituencyLayerMap = new Map();

        // Track currently selected layer for click highlight
        let selectedLayer = null;

        constituencies2019.forEach((constituency) => {
          const isSWAPO = isSWAPOParty(constituency.winner);
          const color = isSWAPO
            ? partyColors["SWAPO"]
            : partyColors[constituency.winner.abbr] ||
              partyColors["Opposition"];

          if (constituency.geometry && constituency.geometry.coordinates) {
            const transformedCoords = transformPolygonCoords(
              constituency.geometry.coordinates
            );

            const layer = L.polygon(transformedCoords, {
              color: "#333",
              weight: 1,
              fillColor: color,
              fillOpacity: 0.6,
            })
              .bindTooltip(
                `
                        <div>
                        <strong>${constituency.name}</strong><br>
                        <span class="tooltip-label">Region:</span> ${
                          constituency.region
                        }<br>
                        <span class="tooltip-label">Winner:</span> ${
                          constituency.winner.abbr
                        } (${constituency.winner.percentage.toFixed(1)}%)<br>
                        <span class="tooltip-label">Runner-up:</span> ${
                          constituency.runnerUp.abbr
                        } (${constituency.runnerUp.percentage.toFixed(1)}%)<br>
                        <span class="tooltip-label">Margin:</span> ${(
                          constituency.winner.percentage -
                          constituency.runnerUp.percentage
                        ).toFixed(1)}%
                        </div>
                    `,
                {
                  permanent: false,
                  sticky: true,
                  direction: "auto",
                  className: "custom-tooltip",
                }
              )
              .on("click", function () {
                // Clear previous selection
                if (selectedLayer && selectedLayer !== layer) {
                  const prevColor = selectedLayer._originalFillColor;
                  selectedLayer.setStyle({
                    fillOpacity: 0.6,
                    weight: 1,
                    color: "#333",
                    fillColor: prevColor,
                  });
                  selectedLayer._isSelected = false;
                }

                // Mark this layer as selected
                selectedLayer = layer;
                layer._isSelected = true;
                layer._originalFillColor = color;

                // Apply selection highlight style (follows actual state shape)
                layer.setStyle({
                  fillOpacity: 0.9,
                  weight: 4,
                  color: "#FFFF00", // Bright yellow border for selection
                  fillColor: color,
                });
                layer.bringToFront();

                openConstituencyDetailPanel(constituency);
              })
              .on("mouseenter", function () {
                // Don't flash if already selected
                if (layer._isSelected) return;

                // Store original style including fillColor
                const originalStyle = {
                  fillOpacity: 0.6,
                  weight: 1,
                  color: "#333",
                  fillColor: color,
                };
                layer._hoverOriginalStyle = originalStyle;

                // Clear any existing interval
                if (layer._hoverInterval) {
                  clearInterval(layer._hoverInterval);
                  layer._hoverInterval = null;
                }

                // Create flashing effect - start immediately
                let isBright = true;
                const flashInterval = setInterval(() => {
                  isBright = !isBright;
                  layer.setStyle({
                    fillOpacity: isBright ? 1.0 : 0.2,
                    weight: isBright ? 4 : 1,
                    color: isBright ? "#ffffff" : "#333333",
                    fillColor: color, // Keep original fill color
                  });
                }, 300); // Flash every 300ms

                // Store interval on layer
                layer._hoverInterval = flashInterval;

                // Apply initial flash
                layer.setStyle({
                  fillOpacity: 1.0,
                  weight: 4,
                  color: "#ffffff",
                  fillColor: color,
                });
              })
              .on("mouseleave", function () {
                // Don't reset if selected
                if (layer._isSelected) return;

                // Clear flashing interval
                if (layer._hoverInterval) {
                  clearInterval(layer._hoverInterval);
                  layer._hoverInterval = null;
                }

                // Restore original style
                if (layer._hoverOriginalStyle) {
                  layer.setStyle(layer._hoverOriginalStyle);
                }
              })
              .addTo(map);

            // Store layer with constituency info for filtering/highlighting
            polygonLayers.push({
              layer: layer,
              constituency: constituency,
              region: constituency.region,
            });

            constituencyLayerMap.set(constituency.name, {
              layer: layer,
              constituency: constituency,
            });
          }
        });

        // Add filterRegion method to map instance
        map.filterRegion = function (region) {
          polygonLayers.forEach(({ layer, region: layerRegion }) => {
            if (region === null) {
              // Clear filter - restore all to normal opacity
              layer.setStyle({ fillOpacity: 0.6, opacity: 1 });
            } else {
              // Filter - dim non-matching regions
              if (layerRegion === region) {
                layer.setStyle({ fillOpacity: 0.8, opacity: 1 });
              } else {
                layer.setStyle({ fillOpacity: 0.2, opacity: 0.5 });
              }
            }
          });
        };

        // Store map instance globally for ENP heatmap to access
        window.map1Instance = map;
        window.map1ConstituencyLayers = constituencyLayerMap;

        // Store selected layer reference globally for clearing
        window.map1SelectedLayer = null;

        // Function to clear the current selection
        window.clearMap1Selection = function () {
          if (selectedLayer) {
            const prevColor = selectedLayer._originalFillColor;
            selectedLayer.setStyle({
              fillOpacity: 0.6,
              weight: 1,
              color: "#333",
              fillColor: prevColor,
            });
            selectedLayer._isSelected = false;
            selectedLayer = null;
          }
        };

        // Setup close button for detail panel
        document
          .getElementById("close-detail-panel")
          .addEventListener("click", function () {
            // Clear the selection highlight when closing the panel
            window.clearMap1Selection();
            document
              .getElementById("constituency-detail-panel")
              .classList.remove("open");
          });

        document.getElementById("legend1").innerHTML = `
                <div class="legend-item">
                    <div class="legend-color" style="background: ${partyColors["SWAPO"]}"></div>
                    <span>SWAPO Dominated</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: ${partyColors["Opposition"]}"></div>
                    <span>Opposition Led</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: ${partyColors["LPM"]}"></div>
                    <span>LPM</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background: ${partyColors["Independent"]}"></div>
                    <span>Independent</span>
                </div>
            `;
      }

      function highlightConstituencyOnMap(constituencyName) {
        const map = window.map1Instance;
        const layerMap = window.map1ConstituencyLayers;
        if (!map || !layerMap) return;

        const layerData = layerMap.get(constituencyName);
        if (!layerData) {
          const fallback = getByYear(2019).find(
            (c) => c.name === constituencyName
          );
          if (fallback) openConstituencyDetailPanel(fallback);
          return;
        }

        const { layer, constituency } = layerData;

        // Clear any existing pulse animation
        if (window.currentPulseInterval) {
          clearInterval(window.currentPulseInterval);
          window.currentPulseInterval = null;
        }
        if (window.currentPulseLayer && window.currentPulseLayer !== layer) {
          window.currentPulseLayer.setStyle({
            fillOpacity: 0.6,
            weight: 1,
            color: "#333",
          });
        }

        window.currentPulseLayer = layer;

        // Focus map on constituency bounds
        const bounds = layer.getBounds();
        map.fitBounds(bounds, { padding: [60, 60] });

        // Scroll map into view
        const mapContainer = document.getElementById("map1");
        if (mapContainer) {
          mapContainer.scrollIntoView({ behavior: "smooth", block: "center" });
        }

        // Pulse highlight animation
        let pulseCount = 0;
        const maxPulses = 6;
        window.currentPulseInterval = setInterval(() => {
          if (pulseCount >= maxPulses) {
            clearInterval(window.currentPulseInterval);
            window.currentPulseInterval = null;
            layer.setStyle({
              fillOpacity: 0.6,
              weight: 1,
              color: "#333",
            });
            window.currentPulseLayer = null;
            return;
          }

          if (pulseCount % 2 === 0) {
            layer.setStyle({
              fillOpacity: 0.95,
              weight: 4,
              color: "#FFFF66",
            });
            try {
              layer.bringToFront();
            } catch (err) {
              // ignore for non-supported layers
            }
          } else {
            layer.setStyle({
              fillOpacity: 0.6,
              weight: 1,
              color: "#333",
            });
          }

          pulseCount++;
        }, 300);

        // Open detail panel after short delay
        setTimeout(() => {
          openConstituencyDetailPanel(constituency);
        }, 500);
      }

      // Function to open constituency detail panel
      function openConstituencyDetailPanel(constituency) {
        const panel = document.getElementById("constituency-detail-panel");
        const content = document.getElementById("detail-content");

        // Get top 3 parties (parties are already normalized)
        const topParties = [...constituency.parties]
          .sort((a, b) => b.percentage - a.percentage)
          .slice(0, 3);

        // Calculate baseline margin
        const baselineMargin =
          constituency.winner.percentage - constituency.runnerUp.percentage;

        // Get turnout if available
        const turnout =
          constituency.turnout || constituency.turnoutPercentage || "N/A";
        const turnoutDisplay =
          typeof turnout === "number" ? turnout.toFixed(1) + "%" : turnout;

        content.innerHTML = `
          <h3>${constituency.name}</h3>
          
          <div class="detail-section">
            <div class="detail-item">
              <span class="detail-label">Region:</span>
              <span>${constituency.region}</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Winner:</span>
              <span>${
                constituency.winner.abbr
              } (${constituency.winner.percentage.toFixed(1)}%)</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Runner-up:</span>
              <span>${
                constituency.runnerUp.abbr
              } (${constituency.runnerUp.percentage.toFixed(1)}%)</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Margin:</span>
              <span>${baselineMargin.toFixed(1)}%</span>
            </div>
            <div class="detail-item">
              <span class="detail-label">Turnout:</span>
              <span>${turnoutDisplay}</span>
            </div>
          </div>
          
          <div class="detail-section">
            <h4>Top 3 Parties</h4>
            <ul class="party-list">
              ${topParties
                .map((party, idx) => {
                  const isSWAPO = isSWAPOParty(party);
                  const color = isSWAPO
                    ? partyColors["SWAPO"]
                    : partyColors[party.abbr] ||
                      partyColors["Opposition"] ||
                      "#95A5A6";
                  const displayName = getDisplayPartyName(party);
                  return `
                  <li style="border-left-color: ${color};">
                    <span class="party-name">${displayName}</span>
                    <span class="party-percentage">${party.percentage.toFixed(
                      1
                    )}%</span>
                  </li>
                `;
                })
                .join("")}
            </ul>
          </div>
          
          <div class="detail-section">
            <h4>Simulation Scenarios</h4>
            <button class="scenario-button" id="btn-coalition-n2" data-constituency="${
              constituency.name
            }">
              Apply Coalition N=2 to this seat
            </button>
            <button class="scenario-button" id="btn-turnout-5pp" data-constituency="${
              constituency.name
            }">
              Add +5pp turnout to this seat
            </button>
            <div class="simulated-result" id="simulated-result">
              <h5>Simulated Result</h5>
              <div id="simulated-details"></div>
            </div>
          </div>
        `;

        // Wire up scenario buttons
        const coalitionBtn = document.getElementById("btn-coalition-n2");
        const turnoutBtn = document.getElementById("btn-turnout-5pp");
        const simulatedResult = document.getElementById("simulated-result");
        const simulatedDetails = document.getElementById("simulated-details");

        let activeScenario = null;

        coalitionBtn.addEventListener("click", function () {
          if (activeScenario === "coalition") {
            // Toggle off
            activeScenario = null;
            coalitionBtn.classList.remove("active");
            simulatedResult.classList.remove("active");
          } else {
            // Toggle on
            activeScenario = "coalition";
            coalitionBtn.classList.add("active");
            turnoutBtn.classList.remove("active");

            // Calculate coalition N=2 scenario
            const result = calculateCoalitionScenario(constituency);
            simulatedDetails.innerHTML = `
              <div class="detail-item">
                <span class="detail-label">Winner:</span>
                <span>${result.winner}</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">Simulated Margin:</span>
                <span>${result.margin.toFixed(1)}%</span>
              </div>
              ${
                result.flipped
                  ? '<div style="color: #27AE60; font-weight: 600; margin-top: 8px;">✓ Would flip to Coalition</div>'
                  : ""
              }
            `;
            simulatedResult.classList.add("active");
          }
        });

        turnoutBtn.addEventListener("click", function () {
          if (activeScenario === "turnout") {
            // Toggle off
            activeScenario = null;
            turnoutBtn.classList.remove("active");
            simulatedResult.classList.remove("active");
          } else {
            // Toggle on
            activeScenario = "turnout";
            turnoutBtn.classList.add("active");
            coalitionBtn.classList.remove("active");

            // Calculate turnout +5pp scenario
            const result = calculateTurnoutScenario(constituency);
            simulatedDetails.innerHTML = `
              <div class="detail-item">
                <span class="detail-label">Winner:</span>
                <span>${result.winner}</span>
              </div>
              <div class="detail-item">
                <span class="detail-label">Simulated Margin:</span>
                <span>${result.margin.toFixed(1)}%</span>
              </div>
              ${
                result.isTarget
                  ? ""
                  : '<div style="color: #F39C12; margin-top: 8px;">Not a target (non-SWAPO ≤ 45%)</div>'
              }
              ${
                result.flipped
                  ? '<div style="color: #27AE60; font-weight: 600; margin-top: 8px;">✓ Would flip to Opposition</div>'
                  : ""
              }
            `;
            simulatedResult.classList.add("active");
          }
        });

        // Open the panel
        panel.classList.add("open");
      }

      // Function to calculate Coalition N=2 scenario
      function calculateCoalitionScenario(constituency) {
        // Separate SWAPO and opposition parties (parties are already normalized)
        const swapoParties = constituency.parties.filter((p) =>
          isSWAPOParty(p)
        );
        const oppositionParties = constituency.parties.filter(
          (p) => !isSWAPOParty(p)
        );

        // Sort opposition by percentage desc and sum top 2
        const sortedOpposition = [...oppositionParties].sort(
          (a, b) => b.percentage - a.percentage
        );
        const top2Opposition = sortedOpposition.slice(
          0,
          Math.min(2, sortedOpposition.length)
        );
        const coalitionPercentage = top2Opposition.reduce(
          (sum, p) => sum + p.percentage,
          0
        );

        // Get SWAPO percentage
        const swapoPercentage =
          swapoParties.length > 0
            ? swapoParties.reduce((sum, p) => sum + p.percentage, 0)
            : 0;

        // Determine winner and margin
        const isCoalitionWin = coalitionPercentage > swapoPercentage;
        const margin = isCoalitionWin
          ? coalitionPercentage - swapoPercentage
          : swapoPercentage - coalitionPercentage;

        const originalIsSWAPO = isSWAPOParty(constituency.winner);
        const flipped = originalIsSWAPO && isCoalitionWin;

        return {
          winner: isCoalitionWin ? "Coalition" : "SWAPO",
          margin: margin,
          flipped: flipped,
        };
      }

      // Function to calculate Turnout +5pp scenario
      function calculateTurnoutScenario(constituency) {
        // Calculate total non-SWAPO percentage (parties are already normalized)
        const swapoParties = constituency.parties.filter((p) =>
          isSWAPOParty(p)
        );
        const oppositionParties = constituency.parties.filter(
          (p) => !isSWAPOParty(p)
        );

        const swapoPercentage =
          swapoParties.length > 0
            ? swapoParties.reduce((sum, p) => sum + p.percentage, 0)
            : 0;
        const oppositionPercentage = oppositionParties.reduce(
          (sum, p) => sum + p.percentage,
          0
        );

        // Only apply to targets (non-SWAPO > 45%)
        if (oppositionPercentage <= 45) {
          // Not a target - return baseline result
          const baselineMargin =
            constituency.winner.percentage - constituency.runnerUp.percentage;
          const winner = isSWAPOParty(constituency.winner)
            ? "SWAPO"
            : "Opposition";
          return {
            winner: winner,
            margin: baselineMargin,
            flipped: false,
            isTarget: false,
          };
        }

        // Simulate +5pp turnout boost for opposition
        const newOppositionTotal = oppositionPercentage + 5;
        const totalAfterBoost = swapoPercentage + newOppositionTotal;
        const renormalizeFactor = 100 / totalAfterBoost;

        // Scale all parties proportionally
        const scaledSwapoParties = swapoParties.map((p) => ({
          ...p,
          percentage: p.percentage * renormalizeFactor,
        }));
        const scaledOppositionParties = oppositionParties.map((p) => ({
          ...p,
          percentage:
            (p.percentage + (5 * p.percentage) / oppositionPercentage) *
            renormalizeFactor,
        }));

        // Find new winner
        const allParties = [
          ...scaledSwapoParties,
          ...scaledOppositionParties,
        ].sort((a, b) => b.percentage - a.percentage);

        const newWinner = allParties[0];
        const newRunnerUp = allParties[1] || { percentage: 0 };
        const newMargin = newWinner.percentage - newRunnerUp.percentage;

        const newIsSWAPO = isSWAPOParty(newWinner);
        const originalIsSWAPO = isSWAPOParty(constituency.winner);
        const flipped = originalIsSWAPO && !newIsSWAPO;

        return {
          winner: newIsSWAPO ? "SWAPO" : "Opposition",
          margin: newMargin,
          flipped: flipped,
          isTarget: true,
        };
      }

      function createMap3() {
        const constituencies2019 = Object.values(processedData).filter(
          (c) => c.year === 2019
        );
        const bounds = getNamibiaBounds(constituencies2019);
        const map = L.map("map3", { attributionControl: false });
        map.fitBounds(bounds);
        map.setMaxBounds(bounds.pad(0.1));

        // Add tile layer with normal/light theme
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "",
          maxZoom: 19,
        }).addTo(map);

        // Toggle button functionality
        const mapContainer = document.getElementById("map3");
        const toggleButton = document.getElementById("map3-toggle");
        let isWhiteBackground = false;

        toggleButton.addEventListener("click", function () {
          isWhiteBackground = !isWhiteBackground;
          if (isWhiteBackground) {
            mapContainer.classList.add("white-bg");
            map.eachLayer(function (layer) {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            toggleButton.textContent = "Show Map Background";
          } else {
            mapContainer.classList.remove("white-bg");
            map.eachLayer(function (layer) {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
              attribution: "",
              maxZoom: 19,
            }).addTo(map);
            toggleButton.textContent = "Show White Background";
          }
        });

        const targetList = identifyTargetConstituencies();

        // Track selected layer for click highlight
        let selectedLayer = null;

        constituencies2019.forEach((constituency) => {
          const isTarget = targetList.some((t) => t.name === constituency.name);
          const color = isTarget ? "#27AE60" : "#ECF0F1";
          const opacity = isTarget ? 0.8 : 0.3;
          const borderColor = isTarget ? "#229954" : "#BDC3C7";
          const borderWeight = isTarget ? 2 : 1;

          if (constituency.geometry) {
            const transformedCoords = transformPolygonCoords(
              constituency.geometry.coordinates
            );

            const layer = L.polygon(transformedCoords, {
              color: borderColor,
              weight: borderWeight,
              fillColor: color,
              fillOpacity: opacity,
            })
              .bindTooltip(
                `<div><strong>${
                  constituency.name
                }</strong><br><span class="tooltip-label">Status:</span> ${
                  isTarget ? "Target Constituency" : "Not prioritized"
                }</div>`,
                {
                  permanent: false,
                  sticky: true,
                  direction: "auto",
                  className: "custom-tooltip",
                }
              )
              .on("click", function () {
                // Clear previous selection
                if (selectedLayer && selectedLayer !== layer) {
                  const prevData = selectedLayer._originalData;
                  selectedLayer.setStyle({
                    fillOpacity: prevData.opacity,
                    weight: prevData.borderWeight,
                    color: prevData.borderColor,
                    fillColor: prevData.color,
                  });
                  selectedLayer._isSelected = false;
                }

                // Mark this layer as selected
                selectedLayer = layer;
                layer._isSelected = true;
                layer._originalData = {
                  color,
                  opacity,
                  borderColor,
                  borderWeight,
                };

                // Apply selection highlight style (follows actual state shape)
                layer.setStyle({
                  fillOpacity: 0.95,
                  weight: 4,
                  color: "#FFFF00", // Bright yellow border for selection
                  fillColor: color,
                });
                layer.bringToFront();
              })
              .on("mouseenter", function () {
                // Don't flash if already selected
                if (layer._isSelected) return;

                const originalStyle = {
                  fillOpacity: opacity,
                  weight: borderWeight,
                  color: borderColor,
                };
                layer._hoverOriginalStyle = originalStyle;

                let isBright = false;
                layer._hoverInterval = setInterval(() => {
                  isBright = !isBright;
                  layer.setStyle({
                    fillOpacity: isBright ? 1.0 : 0.2,
                    weight: isBright ? 4 : borderWeight,
                    color: isBright ? "#fff" : borderColor,
                  });
                }, 300);
              })
              .on("mouseleave", function () {
                // Don't reset if selected
                if (layer._isSelected) return;

                if (layer._hoverInterval) {
                  clearInterval(layer._hoverInterval);
                  layer._hoverInterval = null;
                }
                if (layer._hoverOriginalStyle) {
                  layer.setStyle(layer._hoverOriginalStyle);
                }
              })
              .addTo(map);
          }
        });

        // Click on map background clears selection
        map.on("click", function (e) {
          if (
            e.originalEvent.target ===
            map.getContainer().querySelector(".leaflet-map-pane")
          ) {
            if (selectedLayer) {
              const prevData = selectedLayer._originalData;
              selectedLayer.setStyle({
                fillOpacity: prevData.opacity,
                weight: prevData.borderWeight,
                color: prevData.borderColor,
                fillColor: prevData.color,
              });
              selectedLayer._isSelected = false;
              selectedLayer = null;
            }
          }
        });
      }

      function createMap4() {
        const constituencies2019 = Object.values(processedData).filter(
          (c) => c.year === 2019
        );
        const bounds = getNamibiaBounds(constituencies2019);
        const map = L.map("map4", { attributionControl: false });
        map.fitBounds(bounds);
        map.setMaxBounds(bounds.pad(0.1));

        // Add tile layer with normal/light theme
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "",
          maxZoom: 19,
        }).addTo(map);

        // Toggle button functionality
        const mapContainer = document.getElementById("map4");
        const toggleButton = document.getElementById("map4-toggle");
        let isWhiteBackground = false;

        toggleButton.addEventListener("click", function () {
          isWhiteBackground = !isWhiteBackground;
          if (isWhiteBackground) {
            mapContainer.classList.add("white-bg");
            map.eachLayer(function (layer) {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            toggleButton.textContent = "Show Map Background";
          } else {
            mapContainer.classList.remove("white-bg");
            map.eachLayer(function (layer) {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
              attribution: "",
              maxZoom: 19,
            }).addTo(map);
            toggleButton.textContent = "Show White Background";
          }
        });

        // Track selected layer for click highlight
        let selectedLayer = null;

        constituencies2019.forEach((constituency) => {
          const margin =
            constituency.winner.percentage - constituency.runnerUp.percentage;
          let projectedColor;

          const isSWAPO = isSWAPOParty(constituency.winner);

          if (!isSWAPO) {
            projectedColor = partyColors["Opposition"];
          } else if (margin < 5) {
            projectedColor = partyColors["Competitive"];
          } else if (margin < 15) {
            projectedColor = "#F39C12";
          } else {
            projectedColor = partyColors["SWAPO"];
          }

          if (constituency.geometry) {
            const transformedCoords = transformPolygonCoords(
              constituency.geometry.coordinates
            );

            const layer = L.polygon(transformedCoords, {
              color: "#333",
              weight: 1,
              fillColor: projectedColor,
              fillOpacity: 0.7,
            })
              .bindTooltip(
                `
                        <div>
                        <strong>${constituency.name}</strong><br>
                        <span class="tooltip-label">Status:</span> ${
                          margin < 5
                            ? "Highly Competitive"
                            : margin < 15
                            ? "Competitive"
                            : "Safe"
                        }
                        </div>
                    `,
                {
                  permanent: false,
                  sticky: true,
                  direction: "auto",
                  className: "custom-tooltip",
                }
              )
              .on("click", function () {
                // Clear previous selection
                if (selectedLayer && selectedLayer !== layer) {
                  selectedLayer.setStyle({
                    fillOpacity: 0.7,
                    weight: 1,
                    color: "#333",
                    fillColor: selectedLayer._originalFillColor,
                  });
                  selectedLayer._isSelected = false;
                }

                // Mark this layer as selected
                selectedLayer = layer;
                layer._isSelected = true;
                layer._originalFillColor = projectedColor;

                // Apply selection highlight style (follows actual state shape)
                layer.setStyle({
                  fillOpacity: 0.95,
                  weight: 4,
                  color: "#FFFF00", // Bright yellow border for selection
                  fillColor: projectedColor,
                });
                layer.bringToFront();
              })
              .on("mouseenter", function () {
                // Don't flash if already selected
                if (layer._isSelected) return;

                const originalStyle = {
                  fillOpacity: 0.7,
                  weight: 1,
                  color: "#333",
                };
                layer._hoverOriginalStyle = originalStyle;

                let isBright = false;
                layer._hoverInterval = setInterval(() => {
                  isBright = !isBright;
                  layer.setStyle({
                    fillOpacity: isBright ? 1.0 : 0.3,
                    weight: isBright ? 3 : 1,
                    color: isBright ? "#fff" : "#333",
                  });
                }, 300);
              })
              .on("mouseleave", function () {
                // Don't reset if selected
                if (layer._isSelected) return;

                if (layer._hoverInterval) {
                  clearInterval(layer._hoverInterval);
                  layer._hoverInterval = null;
                }
                if (layer._hoverOriginalStyle) {
                  layer.setStyle(layer._hoverOriginalStyle);
                }
              })
              .addTo(map);
          }
        });

        // Click on map background clears selection
        map.on("click", function (e) {
          if (
            e.originalEvent.target ===
            map.getContainer().querySelector(".leaflet-map-pane")
          ) {
            if (selectedLayer) {
              selectedLayer.setStyle({
                fillOpacity: 0.7,
                weight: 1,
                color: "#333",
                fillColor: selectedLayer._originalFillColor,
              });
              selectedLayer._isSelected = false;
              selectedLayer = null;
            }
          }
        });

        // Create legend for Map 4
        const legend4 = document.getElementById("legend4");
        if (legend4) {
          legend4.innerHTML = `
            <div style="font-weight: 700; font-size: 1.1em; margin-bottom: 12px; color: #ffffff;">Map Legend</div>
            <div style="display: flex; flex-direction: column; gap: 8px;">
              <div style="display: flex; align-items: center; gap: 10px;">
                <div style="width: 24px; height: 24px; background: ${partyColors["Opposition"]}; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3);"></div>
                <span style="color: #ffffff; font-size: 0.95em;">Opposition Win (Projected)</span>
              </div>
              <div style="display: flex; align-items: center; gap: 10px;">
                <div style="width: 24px; height: 24px; background: ${partyColors["Competitive"]}; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3);"></div>
                <span style="color: #ffffff; font-size: 0.95em;">Highly Competitive (<5%)</span>
              </div>
              <div style="display: flex; align-items: center; gap: 10px;">
                <div style="width: 24px; height: 24px; background: #F39C12; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3);"></div>
                <span style="color: #ffffff; font-size: 0.95em;">Competitive (5-15%)</span>
              </div>
              <div style="display: flex; align-items: center; gap: 10px;">
                <div style="width: 24px; height: 24px; background: ${partyColors["SWAPO"]}; border-radius: 4px; border: 1px solid rgba(255,255,255,0.3);"></div>
                <span style="color: #ffffff; font-size: 0.95em;">SWAPO Safe Seat (>15%)</span>
              </div>
            </div>
          `;
        }
      }

      function createShiftMap() {
        const constituencies2014 = getByYear(2014);
        const constituencies2019 = getByYear(2019);

        // Build a map of constituencies by name for quick lookup
        const byName2014 = {};
        constituencies2014.forEach((c) => {
          byName2014[c.name] = c;
        });

        // Find constituencies present in both years
        const shiftData = constituencies2019
          .filter((c) => byName2014[c.name] !== undefined)
          .map((c) => {
            const c2014 = byName2014[c.name];
            const margin2014 = Math.abs(
              c2014.winner.percentage - c2014.runnerUp.percentage
            );
            const margin2019 = Math.abs(
              c.winner.percentage - c.runnerUp.percentage
            );
            const shift = margin2019 - margin2014;
            return {
              name: c.name,
              region: c.region,
              geometry: c.geometry,
              margin2014: margin2014,
              margin2019: margin2019,
              shift: shift,
            };
          });

        const bounds = getNamibiaBounds(
          shiftData.map((d) => ({ geometry: d.geometry }))
        );
        const map = L.map("map-shift", { attributionControl: false });
        map.fitBounds(bounds);
        map.setMaxBounds(bounds.pad(0.1));

        // Add tile layer
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution: "",
          maxZoom: 19,
        }).addTo(map);

        // Toggle button functionality
        const mapContainer = document.getElementById("map-shift");
        const toggleButton = document.getElementById("map-shift-toggle");
        let isWhiteBackground = false;

        toggleButton.addEventListener("click", function () {
          isWhiteBackground = !isWhiteBackground;
          if (isWhiteBackground) {
            mapContainer.classList.add("white-bg");
            map.eachLayer(function (layer) {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            toggleButton.textContent = "Show Map Background";
          } else {
            mapContainer.classList.remove("white-bg");
            map.eachLayer(function (layer) {
              if (layer instanceof L.TileLayer) {
                map.removeLayer(layer);
              }
            });
            L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
              attribution: "",
              maxZoom: 19,
            }).addTo(map);
            toggleButton.textContent = "Show White Background";
          }
        });

        // Color scale: diverging (red-white-blue)
        // Domain: [-15, 0, +15], clamped
        const shiftDomain = [-15, 0, 15];
        const colorScale = d3
          .scaleSequential(d3.interpolateRdBu)
          .domain([shiftDomain[2], shiftDomain[0]]); // Reverse so red is negative, blue is positive

        // Track selected layer for click highlight
        let selectedLayer = null;

        shiftData.forEach((d) => {
          const clampedShift = Math.max(
            shiftDomain[0],
            Math.min(shiftDomain[2], d.shift)
          );
          const color = colorScale(clampedShift);

          if (d.geometry) {
            const transformedCoords = transformPolygonCoords(
              d.geometry.coordinates
            );

            const layer = L.polygon(transformedCoords, {
              color: "#333",
              weight: 1,
              fillColor: color,
              fillOpacity: 0.7,
            })
              .bindTooltip(
                `<div>
                <strong>${d.name}</strong><br>
                <span class="tooltip-label">Region:</span> ${d.region}<br>
                <span class="tooltip-label">Margin 2014:</span> ${d.margin2014.toFixed(
                  1
                )}%<br>
                <span class="tooltip-label">Margin 2019:</span> ${d.margin2019.toFixed(
                  1
                )}%<br>
                <span class="tooltip-label">Shift:</span> ${
                  d.shift >= 0 ? "+" : ""
                }${d.shift.toFixed(1)}%
              </div>`,
                {
                  permanent: false,
                  sticky: true,
                  direction: "auto",
                  className: "custom-tooltip",
                }
              )
              .on("click", function () {
                // Clear previous selection
                if (selectedLayer && selectedLayer !== layer) {
                  selectedLayer.setStyle({
                    fillOpacity: 0.7,
                    weight: 1,
                    color: "#333",
                    fillColor: selectedLayer._originalFillColor,
                  });
                  selectedLayer._isSelected = false;
                }

                // Mark this layer as selected
                selectedLayer = layer;
                layer._isSelected = true;
                layer._originalFillColor = color;

                // Apply selection highlight style (follows actual state shape)
                layer.setStyle({
                  fillOpacity: 0.95,
                  weight: 4,
                  color: "#FFFF00", // Bright yellow border for selection
                  fillColor: color,
                });
                layer.bringToFront();
              })
              .on("mouseenter", function () {
                // Don't flash if already selected
                if (layer._isSelected) return;

                const originalStyle = {
                  fillOpacity: 0.7,
                  weight: 1,
                  color: "#333",
                };
                layer._hoverOriginalStyle = originalStyle;

                let isBright = false;
                layer._hoverInterval = setInterval(() => {
                  isBright = !isBright;
                  layer.setStyle({
                    fillOpacity: isBright ? 1.0 : 0.3,
                    weight: isBright ? 3 : 1,
                    color: isBright ? "#fff" : "#333",
                  });
                }, 300);
              })
              .on("mouseleave", function () {
                // Don't reset if selected
                if (layer._isSelected) return;

                if (layer._hoverInterval) {
                  clearInterval(layer._hoverInterval);
                  layer._hoverInterval = null;
                }
                if (layer._hoverOriginalStyle) {
                  layer.setStyle(layer._hoverOriginalStyle);
                }
              })
              .addTo(map);
          }
        });

        // Click on map background clears selection
        map.on("click", function (e) {
          if (
            e.originalEvent.target ===
            map.getContainer().querySelector(".leaflet-map-pane")
          ) {
            if (selectedLayer) {
              selectedLayer.setStyle({
                fillOpacity: 0.7,
                weight: 1,
                color: "#333",
                fillColor: selectedLayer._originalFillColor,
              });
              selectedLayer._isSelected = false;
              selectedLayer = null;
            }
          }
        });

        // Create legend
        const legendContainer = document.getElementById("legend-shift");
        const legendValues = [-15, -7.5, 0, 7.5, 15];
        legendContainer.innerHTML = legendValues
          .map((val) => {
            const color = colorScale(val);
            return `
            <div class="legend-item">
              <div class="legend-color" style="background: ${color}"></div>
              <span>${val >= 0 ? "+" : ""}${val}%</span>
            </div>
          `;
          })
          .join("");
      }

      function createCoalitionMap() {
        const constituencies2019 = getByYear(2019);
        const bounds = getNamibiaBounds(constituencies2019);
        const map = L.map("map-coalition", { attributionControl: false });
        map.fitBounds(bounds);
        map.setMaxBounds(bounds.pad(0.1));

        // Track tile layer separately
        let tileLayer = L.tileLayer(
          "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          {
            attribution: "",
            maxZoom: 19,
          }
        ).addTo(map);

        // Toggle button functionality
        const mapContainer = document.getElementById("map-coalition");
        const toggleButton = document.getElementById("map-coalition-toggle");
        let isWhiteBackground = false;

        toggleButton.addEventListener("click", function () {
          isWhiteBackground = !isWhiteBackground;
          if (isWhiteBackground) {
            mapContainer.classList.add("white-bg");
            if (tileLayer) {
              map.removeLayer(tileLayer);
              tileLayer = null;
            }
            toggleButton.textContent = "Show Map Background";
          } else {
            mapContainer.classList.remove("white-bg");
            if (!tileLayer) {
              tileLayer = L.tileLayer(
                "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
                {
                  attribution: "",
                  maxZoom: 19,
                }
              ).addTo(map);
            }
            toggleButton.textContent = "Show White Background";
          }
        });

        let currentLayers = [];

        // Track selected layer for click highlight
        let selectedLayer = null;

        function recompute(n) {
          // Clear existing layers and selection
          currentLayers.forEach((layer) => map.removeLayer(layer));
          currentLayers = [];
          selectedLayer = null;

          let flipsCount = 0;

          constituencies2019.forEach((constituency) => {
            // Separate SWAPO and opposition parties (parties are already normalized)
            const swapoParties = constituency.parties.filter((p) =>
              isSWAPOParty(p)
            );
            const oppositionParties = constituency.parties.filter(
              (p) => !isSWAPOParty(p)
            );

            // Sort opposition by percentage desc and sum top n (use all available if fewer than n)
            const sortedOpposition = [...oppositionParties].sort(
              (a, b) => b.percentage - a.percentage
            );
            const actualN = Math.min(n, sortedOpposition.length);
            const topNOpposition = sortedOpposition.slice(0, actualN);
            const coalitionPercentage = topNOpposition.reduce(
              (sum, p) => sum + p.percentage,
              0
            );
            const coalitionParties = topNOpposition.map((p) => p.abbr);

            // Get SWAPO percentage
            const swapoPercentage =
              swapoParties.length > 0
                ? swapoParties.reduce((sum, p) => sum + p.percentage, 0)
                : 0;

            // Determine winner and margin
            const originalWinner = constituency.winner;
            const originalIsSWAPO = isSWAPOParty(originalWinner);
            const originalMargin =
              constituency.winner.percentage - constituency.runnerUp.percentage;

            let simulatedWinner, simulatedMargin, simulatedIsCoalitionWin;

            if (coalitionPercentage > swapoPercentage) {
              simulatedWinner = {
                name: "Coalition",
                abbr: "Coalition",
                percentage: coalitionPercentage,
              };
              simulatedMargin = coalitionPercentage - swapoPercentage;
              simulatedIsCoalitionWin = true;
            } else {
              simulatedWinner = {
                name: "SWAPO",
                abbr: "SWAPO",
                percentage: swapoPercentage,
              };
              simulatedMargin = swapoPercentage - coalitionPercentage;
              simulatedIsCoalitionWin = false;
            }

            // Count flips: SWAPO originally won but Coalition would now win
            if (originalIsSWAPO && simulatedIsCoalitionWin) {
              flipsCount++;
            }

            // Determine color
            let color;
            if (simulatedIsCoalitionWin) {
              color = partyColors["Coordinated"] || "#27AE60";
            } else if (simulatedMargin < 5) {
              color = partyColors["Competitive"] || "#F39C12";
            } else {
              color = partyColors["SWAPO"] || "#E74C3C";
            }

            if (constituency.geometry) {
              const transformedCoords = transformPolygonCoords(
                constituency.geometry.coordinates
              );

              const layer = L.polygon(transformedCoords, {
                color: "#333",
                weight: 1,
                fillColor: color,
                fillOpacity: 0.7,
              })
                .bindTooltip(
                  `<div>
                  <strong>${constituency.name}</strong><br>
                  <span class="tooltip-label">Original (2019):</span> ${
                    originalWinner.abbr
                  } won by ${originalMargin.toFixed(1)}%<br>
                  <span class="tooltip-label">Simulated:</span> ${
                    simulatedWinner.abbr
                  } wins by ${simulatedMargin.toFixed(1)}%<br>
                  <span class="tooltip-label">Coalition parties:</span> ${coalitionParties.join(
                    ", "
                  )}
                </div>`,
                  {
                    permanent: false,
                    sticky: true,
                    direction: "auto",
                    className: "custom-tooltip",
                  }
                )
                .on("click", function () {
                  // Clear previous selection
                  if (selectedLayer && selectedLayer !== layer) {
                    selectedLayer.setStyle({
                      fillOpacity: 0.7,
                      weight: 1,
                      color: "#333",
                      fillColor: selectedLayer._originalFillColor,
                    });
                    selectedLayer._isSelected = false;
                  }

                  // Mark this layer as selected
                  selectedLayer = layer;
                  layer._isSelected = true;
                  layer._originalFillColor = color;

                  // Apply selection highlight style (follows actual state shape)
                  layer.setStyle({
                    fillOpacity: 0.95,
                    weight: 4,
                    color: "#FFFF00", // Bright yellow border for selection
                    fillColor: color,
                  });
                  layer.bringToFront();
                })
                .on("mouseenter", function () {
                  // Don't flash if already selected
                  if (layer._isSelected) return;

                  const originalStyle = {
                    fillOpacity: 0.7,
                    weight: 1,
                    color: "#333",
                  };
                  layer._hoverOriginalStyle = originalStyle;

                  let isBright = false;
                  layer._hoverInterval = setInterval(() => {
                    isBright = !isBright;
                    layer.setStyle({
                      fillOpacity: isBright ? 1.0 : 0.3,
                      weight: isBright ? 3 : 1,
                      color: isBright ? "#fff" : "#333",
                    });
                  }, 300);
                })
                .on("mouseleave", function () {
                  // Don't reset if selected
                  if (layer._isSelected) return;

                  if (layer._hoverInterval) {
                    clearInterval(layer._hoverInterval);
                    layer._hoverInterval = null;
                  }
                  if (layer._hoverOriginalStyle) {
                    layer.setStyle(layer._hoverOriginalStyle);
                  }
                })
                .addTo(map);

              currentLayers.push(layer);
            }
          });

          // Update KPI
          document.getElementById("flips-count").textContent = flipsCount;

          // Update legend
          updateCoalitionLegend();
        }

        function updateCoalitionLegend() {
          const legendContainer = document.getElementById("legend-coalition");
          legendContainer.innerHTML = `
            <div class="legend-item">
              <div class="legend-color" style="background: ${
                partyColors["Coordinated"] || "#27AE60"
              }"></div>
              <span>Coalition Wins</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: ${
                partyColors["Competitive"] || "#F39C12"
              }"></div>
              <span>SWAPO Wins (margin &lt; 5%)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color" style="background: ${
                partyColors["SWAPO"] || "#E74C3C"
              }"></div>
              <span>SWAPO Wins (margin ≥ 5%)</span>
            </div>
          `;
        }

        // Initial legend
        updateCoalitionLegend();

        // Hook up slider
        const slider = document.getElementById("coalition-n");
        const valueDisplay = document.getElementById("coalition-n-value");

        slider.addEventListener("input", function () {
          const n = parseInt(this.value);
          valueDisplay.textContent = n;
          valueDisplay.style.fontSize = "2.5em";
          recompute(n);
        });

        // Click on map background clears selection
        map.on("click", function (e) {
          if (
            e.originalEvent.target ===
            map.getContainer().querySelector(".leaflet-map-pane")
          ) {
            if (selectedLayer) {
              selectedLayer.setStyle({
                fillOpacity: 0.7,
                weight: 1,
                color: "#333",
                fillColor: selectedLayer._originalFillColor,
              });
              selectedLayer._isSelected = false;
              selectedLayer = null;
            }
          }
        });

        // Initial computation
        recompute(2);
      }

      function createMarginBeeswarm() {
        const container = document.getElementById("margin-beeswarm");

        function effectiveNumberOfParties(parties) {
          const shares = parties.map((p) => p.percentage / 100);
          const denom = shares.reduce((s, v) => s + v * v, 0);
          return denom > 0 ? 1 / denom : 0;
        }

        function draw(year) {
          const data = getByYear(year).map((c) => ({
            name: c.name,
            region: c.region,
            margin: c.winner.percentage - c.runnerUp.percentage,
            winner: c.winner,
            isSWAPO: isSWAPOParty(c.winner),
          }));

          // Adjust margins for compact layout
          const margin = { top: 25, right: 120, bottom: 50, left: 100 };
          const containerWidth = Math.min(
            container.offsetWidth || 900,
            window.innerWidth - 40
          );
          const width = containerWidth - margin.left - margin.right;
          // Use container height or fallback, capped for reasonable size
          const containerHeight = container.offsetHeight || 400;
          const height = Math.min(
            Math.max(containerHeight - margin.top - margin.bottom, 250),
            400
          );

          d3.select(container).selectAll("svg").remove();

          let tooltip = d3.select(".d3-tooltip-margin");
          if (tooltip.empty()) {
            tooltip = d3
              .select("body")
              .append("div")
              .attr("class", "d3-tooltip d3-tooltip-margin")
              .style("opacity", 0)
              .style("position", "fixed")
              .style("background", "rgba(26, 31, 58, 0.95)")
              .style("color", "#ffffff")
              .style("padding", "12px")
              .style("border-radius", "8px")
              .style("pointer-events", "none")
              .style("font-size", "14px")
              .style("z-index", "10000")
              .style("max-width", "250px")
              .style("border", "1px solid rgba(255, 255, 255, 0.2)")
              .style("box-shadow", "0 4px 12px rgba(0, 0, 0, 0.4)");
          }

          const svg = d3
            .select(container)
            .append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .attr(
              "viewBox",
              `0 0 ${width + margin.left + margin.right} ${
                height + margin.top + margin.bottom
              }`
            )
            .attr("preserveAspectRatio", "xMidYMid meet")
            .style("max-width", "100%")
            .style("height", "auto");

          const g = svg
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

          const xScale = d3
            .scaleLinear()
            .domain([0, d3.max(data, (d) => d.margin) + 5])
            .nice()
            .range([0, width]);

          // Jitter/beeswarm: stack points vertically with force collision
          const radius = 5;
          const jitterHeight = 40;
          const simulation = d3
            .forceSimulation(data)
            .force("x", d3.forceX((d) => xScale(d.margin)).strength(0.5))
            .force("y", d3.forceY(height / 2))
            .force("collision", d3.forceCollide().radius(radius + 2))
            .stop();

          for (let i = 0; i < 100; ++i) simulation.tick();

          // Draw guide lines at 5% and 15%
          g.append("line")
            .attr("x1", xScale(5))
            .attr("x2", xScale(5))
            .attr("y1", 0)
            .attr("y2", height)
            .attr("stroke", "#F39C12")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5,5")
            .attr("opacity", 0.7);

          g.append("line")
            .attr("x1", xScale(15))
            .attr("x2", xScale(15))
            .attr("y1", 0)
            .attr("y2", height)
            .attr("stroke", "#E74C3C")
            .attr("stroke-width", 2)
            .attr("stroke-dasharray", "5,5")
            .attr("opacity", 0.7);

          g.append("text")
            .attr("x", xScale(5))
            .attr("y", -10)
            .attr("text-anchor", "middle")
            .attr("class", "d3-axis-label")
            .style("font-size", "14px")
            .style("fill", "#ffffff")
            .style("font-weight", "600")
            .text("5%");

          g.append("text")
            .attr("x", xScale(15))
            .attr("y", -10)
            .attr("text-anchor", "middle")
            .attr("class", "d3-axis-label")
            .style("font-size", "14px")
            .style("fill", "#ffffff")
            .style("font-weight", "600")
            .text("15%");

          // Draw points
          g.selectAll(".point")
            .data(data)
            .enter()
            .append("circle")
            .attr("class", "point")
            .attr("cx", (d) => d.x)
            .attr("cy", (d) => d.y)
            .attr("r", radius)
            .attr("fill", (d) =>
              d.isSWAPO ? partyColors["SWAPO"] : partyColors["Opposition"]
            )
            .attr("opacity", 0.7)
            .style("cursor", "pointer")
            .style("touch-action", "none")
            .on("mouseover touchstart", function (event, d) {
              event.preventDefault();
              const touch = event.touches ? event.touches[0] : event;
              tooltip.transition().style("opacity", 1);
              tooltip
                .html(
                  `<strong>${d.name}</strong><br/>` +
                    `Region: ${d.region}<br/>` +
                    `Winner: ${d.winner.abbr}<br/>` +
                    `Margin: ${d.margin.toFixed(1)}%`
                )
                .style("left", touch.clientX + 15 + "px")
                .style("top", touch.clientY - 10 + "px");
            })
            .on("mouseout touchend touchcancel", function () {
              // Delay hiding on touch devices to allow reading
              setTimeout(() => {
                tooltip.transition().duration(200).style("opacity", 0);
              }, 2000);
            });

          // X axis
          const xAxis = d3.axisBottom(xScale).tickFormat((d) => d + "%");
          const xAxisGroup = g
            .append("g")
            .attr("class", "d3-axis")
            .attr("transform", `translate(0,${height})`)
            .style("color", "#ffffff")
            .style("font-size", "14px")
            .call(xAxis);

          // Make axis line and ticks white
          xAxisGroup.selectAll("path").style("stroke", "#ffffff");
          xAxisGroup.selectAll("line").style("stroke", "#ffffff");
          xAxisGroup
            .selectAll("text")
            .style("fill", "#ffffff")
            .style("font-size", "14px")
            .style("font-weight", "500");

          // X axis label
          g.append("text")
            .attr("class", "d3-axis-label")
            .attr("transform", `translate(${width / 2},${height + 40})`)
            .style("text-anchor", "middle")
            .style("fill", "#ffffff")
            .style("font-size", "15px")
            .style("font-weight", "600")
            .text("Winning Margin (%)");

          // Y axis (simple line with label for beeswarm distribution)
          const yAxisGroup = g.append("g").attr("class", "d3-axis");

          // Y axis line
          yAxisGroup
            .append("line")
            .attr("x1", 0)
            .attr("x2", 0)
            .attr("y1", 0)
            .attr("y2", height)
            .style("stroke", "#ffffff")
            .style("stroke-width", 1);

          // Y axis label
          g.append("text")
            .attr("class", "d3-axis-label")
            .attr("transform", `translate(-50,${height / 2}) rotate(-90)`)
            .style("text-anchor", "middle")
            .style("fill", "#ffffff")
            .style("font-size", "15px")
            .style("font-weight", "600")
            .text("Constituencies");

          // Legend - positioned on the right side to avoid overlap with guide lines
          const legend = g
            .append("g")
            .attr("transform", `translate(${width - 140}, 15)`);
          const legendData = [
            { label: "SWAPO-won", color: partyColors["SWAPO"] },
            { label: "Opposition-won", color: partyColors["Opposition"] },
          ];
          legend
            .selectAll(".legend-item")
            .data(legendData)
            .enter()
            .append("g")
            .attr("class", "legend-item")
            .attr("transform", (d, i) => `translate(0,${i * 28})`)
            .each(function (d) {
              const g = d3.select(this);
              g.append("circle")
                .attr("r", 6)
                .attr("fill", d.color)
                .attr("cx", 0)
                .attr("cy", 0);
              g.append("text")
                .attr("x", 14)
                .attr("y", 4)
                .attr("class", "d3-axis-label")
                .style("font-size", "14px")
                .style("font-weight", "600")
                .style("fill", "#f5f5dc")
                .text(d.label);
            });
        }

        // Hook up radio buttons
        document
          .querySelectorAll('input[name="margin-year"]')
          .forEach((radio) => {
            radio.addEventListener("change", function () {
              if (this.checked) {
                draw(parseInt(this.value));
              }
            });
          });

        // Initial draw
        draw(2019);
      }

      function createENPHeatmap() {
        const container = document.getElementById("enp-heatmap");

        function effectiveNumberOfParties(parties) {
          const shares = parties.map((p) => p.percentage / 100);
          const denom = shares.reduce((s, v) => s + v * v, 0);
          return denom > 0 ? 1 / denom : 0;
        }

        // Get all regions
        const constituencies2014 = getByYear(2014);
        const constituencies2019 = getByYear(2019);
        const allRegions = Array.from(
          new Set([
            ...constituencies2014.map((c) => c.region),
            ...constituencies2019.map((c) => c.region),
          ])
        ).sort();

        const years = [2014, 2019];

        // Calculate mean ENP per region/year
        const enpData = {};
        allRegions.forEach((region) => {
          enpData[region] = {};
          years.forEach((year) => {
            const regionConstituencies = getByYear(year).filter(
              (c) => c.region === region
            );
            if (regionConstituencies.length > 0) {
              const enpValues = regionConstituencies.map((c) =>
                effectiveNumberOfParties(c.parties)
              );
              const meanENP =
                enpValues.reduce((a, b) => a + b, 0) / enpValues.length;
              enpData[region][year] = meanENP;
            } else {
              enpData[region][year] = null;
            }
          });
        });

        // Find min/max for color scale
        const allENPs = Object.values(enpData)
          .flatMap((r) => Object.values(r))
          .filter((v) => v !== null);
        const minENP = d3.min(allENPs);
        const maxENP = d3.max(allENPs);

        const colorScale = d3
          .scaleSequential(d3.interpolateYlOrRd)
          .domain([minENP, maxENP]);

        // Add color scale legend first - compact version
        const legendHtml = `
          <div style="margin: 0 0 10px 0; padding: 10px 15px; background: rgba(26, 31, 58, 0.5); border-radius: 10px; border: 1px solid rgba(90, 103, 216, 0.3);">
            <div style="display: flex; align-items: center; gap: 12px; justify-content: center; flex-wrap: wrap;">
              <span style="color: #ffffff; font-weight: 600; font-size: 0.9em;">ENP Scale:</span>
              <span style="color: rgba(255, 255, 255, 0.85); font-size: 0.85em; font-weight: 500;">${minENP.toFixed(
                1
              )} (Less fragmented)</span>
              <div style="flex: 0 0 200px; height: 18px; background: linear-gradient(to right, ${colorScale(
                minENP
              )}, ${colorScale(
          maxENP
        )}); border-radius: 4px; border: 1px solid rgba(255, 255, 255, 0.2);"></div>
              <span style="color: rgba(255, 255, 255, 0.85); font-size: 0.85em; font-weight: 500;">${maxENP.toFixed(
                1
              )} (More fragmented)</span>
            </div>
          </div>
        `;

        // Create table with equal column widths and compact styling - no max-height to fit page
        let html = legendHtml;
        html +=
          '<div style="overflow-x: auto; flex: 1;"><table style="width: 100%; border-collapse: collapse; margin: 0 auto; max-width: 800px; table-layout: fixed;">';
        html += "<thead><tr>";
        html +=
          '<th style="padding: 8px 10px; text-align: center; background: rgba(26, 31, 58, 0.8); color: #ffffff; border: 1px solid rgba(255, 255, 255, 0.2); width: 40%; font-size: 0.9em; font-weight: 600; position: sticky; top: 0; z-index: 10;">Region</th>';
        years.forEach((year) => {
          html += `<th style="padding: 8px 10px; text-align: center; background: rgba(26, 31, 58, 0.8); color: #ffffff; border: 1px solid rgba(255, 255, 255, 0.2); width: 30%; font-size: 0.9em; font-weight: 600; position: sticky; top: 0; z-index: 10;">${year}</th>`;
        });
        html += "</tr></thead><tbody>";

        allRegions.forEach((region) => {
          html += `<tr>`;
          html += `<td style="padding: 6px 10px; text-align: left; background: rgba(26, 31, 58, 0.5); color: #ffffff; border: 1px solid rgba(255, 255, 255, 0.1); font-weight: 500; font-size: 0.85em;">${region}</td>`;
          years.forEach((year) => {
            const enp = enpData[region][year];
            const bgColor = enp !== null ? colorScale(enp) : "#cccccc";
            const textColor = enp !== null ? "#000000" : "#888888";
            const displayValue = enp !== null ? enp.toFixed(1) : "N/A";
            html += `<td class="enp-cell" data-region="${region}" data-year="${year}" 
                     style="padding: 8px; text-align: center; background: ${bgColor}; color: ${textColor}; 
                     border: 1px solid rgba(0, 0, 0, 0.2); cursor: pointer; font-weight: 700;
                     font-size: 0.95em; transition: all 0.2s ease;" 
                     onmouseover="this.style.transform='scale(1.03)'; this.style.boxShadow='0 3px 10px rgba(0,0,0,0.4)'; this.style.zIndex='20';"
                     onmouseout="this.style.transform='scale(1)'; this.style.boxShadow='none'; this.style.zIndex='1';">
                     ${displayValue}</td>`;
          });
          html += `</tr>`;
        });

        html += "</tbody></table></div>";
        container.innerHTML = html;

        // Store map1 layers for filtering
        let map1Layers = [];
        let filteredRegion = null;

        // Click handler for cells
        container.querySelectorAll(".enp-cell").forEach((cell) => {
          cell.addEventListener("click", function () {
            const region = this.getAttribute("data-region");
            const year = this.getAttribute("data-year");

            if (filteredRegion === region) {
              // Clear filter
              clearRegionFilter();
            } else {
              // Apply filter
              filterMap1ByRegion(region);
              filteredRegion = region;
              document.getElementById("clear-region-filter").style.display =
                "inline-block";
            }
          });
        });

        function filterMap1ByRegion(region) {
          // Filter map1 to highlight only the selected region
          if (window.map1Instance && window.map1Instance.filterRegion) {
            window.map1Instance.filterRegion(region);
          }
        }

        function clearRegionFilter() {
          filteredRegion = null;
          document.getElementById("clear-region-filter").style.display = "none";
          if (window.map1Instance && window.map1Instance.filterRegion) {
            window.map1Instance.filterRegion(null);
          }
        }

        document
          .getElementById("clear-region-filter")
          .addEventListener("click", clearRegionFilter);
      }

      function identifyTargetConstituencies() {
        const constituencies2019 = Object.values(processedData).filter(
          (c) => c.year === 2019
        );

        return constituencies2019
          .map((c) => {
            const margin = c.winner.percentage - c.runnerUp.percentage;
            const isSWAPO = isSWAPOParty(c.winner);
            const oppositionTotal = c.parties
              .filter((p) => !isSWAPOParty(p))
              .reduce((sum, p) => sum + p.percentage, 0);

            // Get top non-SWAPO parties (parties are already normalized)
            const nonSWAPOParties = c.parties.filter((p) => !isSWAPOParty(p));

            return {
              name: c.name,
              region: c.region,
              margin: margin,
              winnabilityScore: isSWAPO
                ? 100 - margin + (oppositionTotal - c.winner.percentage)
                : 100,
              parties: nonSWAPOParties.slice(0, 3),
              isSWAPO: isSWAPO,
            };
          })
          .filter((c) => c.isSWAPO)
          .sort((a, b) => b.winnabilityScore - a.winnabilityScore)
          .slice(0, 15);
      }

      function createClosestRacesChart() {
        const container = document.getElementById("closest-races-chart");
        if (!container) {
          return;
        }

        const yearRadios = document.querySelectorAll(
          'input[name="closest-year"]'
        );
        let selectedYear = 2019;
        yearRadios.forEach((radio) => {
          if (radio.checked) {
            selectedYear = parseInt(radio.value, 10);
          }
        });

        if (
          yearRadios.length > 0 &&
          !yearRadios[0].hasAttribute("data-closest-wired")
        ) {
          yearRadios.forEach((radio) => {
            radio.setAttribute("data-closest-wired", "true");
            radio.addEventListener("change", createClosestRacesChart);
          });
        }

        const constituencies = getByYear(selectedYear) || [];
        if (constituencies.length === 0) {
          container.innerHTML = `<p style="text-align:center; padding: 30px; color: #f5f5dc;">No data available for ${selectedYear}.</p>`;
          return;
        }

        const closestRaces = constituencies
          .map((c) => ({
            name: c.name,
            region: c.region,
            margin: c.winner.percentage - c.runnerUp.percentage,
            winner: c.winner,
            runnerUp: c.runnerUp,
            constituency: c,
          }))
          .sort((a, b) => a.margin - b.margin)
          .slice(0, 15);

        d3.select(container).selectAll("*").remove();

        const margin = { top: 30, right: 80, bottom: 45, left: 140 };
        const containerWidth = container.offsetWidth || 900;
        const containerHeight = container.offsetHeight || 600;
        const width = containerWidth - margin.left - margin.right;
        // Calculate height to fit all bars within container (accounting for axis)
        const availableHeight =
          containerHeight - margin.top - margin.bottom - 10;
        const barHeight = Math.max(
          Math.floor(availableHeight / closestRaces.length),
          22
        );
        const height = closestRaces.length * barHeight;

        const svg = d3
          .select(container)
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);

        const g = svg
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        let tooltip = d3.select(".d3-tooltip-closest");
        if (tooltip.empty()) {
          tooltip = d3
            .select("body")
            .append("div")
            .attr("class", "d3-tooltip d3-tooltip-closest")
            .style("opacity", 0)
            .style("position", "fixed")
            .style("background", "rgba(26, 31, 58, 0.95)")
            .style("color", "#ffffff")
            .style("padding", "12px")
            .style("border-radius", "8px")
            .style("pointer-events", "none")
            .style("font-size", "14px")
            .style("z-index", "10000")
            .style("max-width", "280px")
            .style("border", "1px solid rgba(255, 255, 255, 0.2)")
            .style("box-shadow", "0 4px 12px rgba(0, 0, 0, 0.4)");
        }

        const xScale = d3
          .scaleLinear()
          .domain([0, d3.max(closestRaces, (d) => d.margin) * 1.1])
          .nice()
          .range([0, width]);

        const yScale = d3
          .scaleBand()
          .domain(closestRaces.map((_, i) => i))
          .range([0, height])
          .padding(0.15);

        const getBarColor = (d) => {
          const isSWAPO = isSWAPOParty(d.winner);
          if (isSWAPO) {
            return d.margin < 5
              ? partyColors["Competitive"] || "#F39C12"
              : partyColors["SWAPO"] || "#E74C3C";
          }
          return partyColors["Opposition"] || "#3498DB";
        };

        const onBarClick = (event, d) => {
          event.stopPropagation();
          highlightConstituencyOnMap(d.name);
        };

        g.selectAll(".closest-bar")
          .data(closestRaces)
          .enter()
          .append("rect")
          .attr("class", "closest-bar")
          .attr("x", 0)
          .attr("y", (_, i) => yScale(i))
          .attr("width", (d) => xScale(d.margin))
          .attr("height", yScale.bandwidth())
          .attr("fill", getBarColor)
          .attr("rx", 6)
          .style("cursor", "pointer")
          .on("mouseover", function (event, d) {
            d3.select(this).attr("opacity", 0.85);
            tooltip.transition().duration(150).style("opacity", 1);
            tooltip
              .html(
                `<strong>${d.name}</strong><br/>` +
                  `<span class="tooltip-label">Region:</span> ${d.region}<br/>` +
                  `<span class="tooltip-label">Winner:</span> ${
                    d.winner.abbr
                  } (${d.winner.percentage.toFixed(1)}%)<br/>` +
                  `<span class="tooltip-label">Runner-up:</span> ${
                    d.runnerUp.abbr
                  } (${d.runnerUp.percentage.toFixed(1)}%)<br/>` +
                  `<span class="tooltip-label">Margin:</span> ${d.margin.toFixed(
                    1
                  )}%`
              )
              .style("left", event.pageX + 15 + "px")
              .style("top", event.pageY - 10 + "px");
          })
          .on("mousemove", function (event) {
            tooltip
              .style("left", event.pageX + 15 + "px")
              .style("top", event.pageY - 10 + "px");
          })
          .on("mouseout", function () {
            d3.select(this).attr("opacity", 1);
            tooltip.transition().duration(150).style("opacity", 0);
          })
          .on("click", onBarClick);

        // Margin labels
        g.selectAll(".closest-bar-label")
          .data(closestRaces)
          .enter()
          .append("text")
          .attr("class", "closest-bar-label")
          .attr("x", (d) => xScale(d.margin) + 6)
          .attr("y", (_, i) => yScale(i) + yScale.bandwidth() / 2)
          .attr("dy", "0.35em")
          .attr("fill", "#ffffff")
          .attr("font-size", "11px")
          .attr("font-weight", "600")
          .text((d) => `${d.margin.toFixed(1)}%`);

        // Name labels
        g.selectAll(".closest-name-label")
          .data(closestRaces)
          .enter()
          .append("text")
          .attr("class", "closest-name-label")
          .attr("x", -8)
          .attr("y", (_, i) => yScale(i) + yScale.bandwidth() / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", "end")
          .attr("fill", "#ffffff")
          .attr("font-size", "11px")
          .attr("font-weight", "500")
          .style("cursor", "pointer")
          .text((d) => d.name)
          .on("click", onBarClick);

        const xAxis = d3.axisBottom(xScale).tickFormat((d) => d + "%");
        const xAxisGroup = g
          .append("g")
          .attr("class", "d3-axis")
          .attr("transform", `translate(0,${height})`)
          .call(xAxis);

        xAxisGroup.selectAll("path, line").style("stroke", "#ffffff");
        xAxisGroup
          .selectAll("text")
          .style("fill", "#ffffff")
          .style("font-size", "11px")
          .style("font-weight", "600");

        g.append("text")
          .attr("class", "d3-axis-label")
          .attr("transform", `translate(${width / 2},${height + 32})`)
          .style("text-anchor", "middle")
          .style("fill", "#ffffff")
          .style("font-size", "13px")
          .style("font-weight", "600")
          .text("Winning Margin (%)");

        // Guide line at 5%
        g.append("line")
          .attr("x1", xScale(5))
          .attr("x2", xScale(5))
          .attr("y1", 0)
          .attr("y2", height)
          .attr("stroke", "#F39C12")
          .attr("stroke-width", 2)
          .attr("stroke-dasharray", "5,5")
          .attr("opacity", 0.7);

        g.append("text")
          .attr("x", xScale(5))
          .attr("y", -10)
          .attr("text-anchor", "middle")
          .style("fill", "#F39C12")
          .style("font-size", "12px")
          .style("font-weight", "600")
          .text("5%");
      }

      function createTargetConstituencies() {
        const targets = identifyTargetConstituencies();
        const container = document.getElementById("target-constituencies");

        container.innerHTML = targets
          .map(
            (target, index) => `
                <div class="constituency-card">
                    <div class="constituency-name">${index + 1}. ${
              target.name
            }</div>
                    <div class="constituency-region">${target.region}</div>
                      ${target.parties
                        .map(
                          (party, partyIndex) => `
                        <div class="party-bar-wrapper">
                            <div class="party-bar" 
                                 style="background: ${
                                   partyColors[party.abbr] || "#95A5A6"
                                 }; width: ${Math.max(party.percentage, 10)}%;" 
                                 title="${getDisplayPartyName(party)}"
                                 data-party-name="${getDisplayPartyName(party)}"
                                 data-party-index="${index}-${partyIndex}">
                                <span>${getDisplayPartyAbbr(party)}</span>
                            </div>
                            <span class="party-bar-percentage" 
                                  title="${getDisplayPartyName(party)}"
                                  data-party-name="${getDisplayPartyName(
                                    party
                                  )}"
                                  data-party-index="${index}-${partyIndex}">${party.percentage.toFixed(
                            1
                          )}%</span>
                        </div>
                    `
                        )
                        .join("")}
                </div>
            `
          )
          .join("");

        // Add touch-friendly tooltips for iOS/mobile
        container
          .querySelectorAll(".party-bar, .party-bar-percentage")
          .forEach((element) => {
            const partyName = element.getAttribute("data-party-name");
            if (!partyName) return;

            let tooltip = null;
            let hideTimeout = null;

            const showTooltip = (e) => {
              e.preventDefault();
              e.stopPropagation();

              if (tooltip) {
                tooltip.remove();
              }

              tooltip = document.createElement("div");
              tooltip.className = "mobile-party-tooltip";
              tooltip.textContent = partyName;
              tooltip.style.cssText = `
              position: absolute;
              background: rgba(26, 31, 58, 0.98);
              color: #ffffff;
              padding: 10px 16px;
              border-radius: 10px;
              font-size: 13px;
              font-weight: 500;
              z-index: 10000;
              pointer-events: none;
              white-space: nowrap;
              max-width: 250px;
              word-wrap: break-word;
              border: 1px solid rgba(255, 255, 255, 0.2);
              box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
              backdrop-filter: blur(10px);
            `;

              document.body.appendChild(tooltip);

              const rect = element.getBoundingClientRect();
              tooltip.style.left =
                rect.left + rect.width / 2 - tooltip.offsetWidth / 2 + "px";
              tooltip.style.top = rect.top - tooltip.offsetHeight - 8 + "px";

              // Adjust if tooltip goes off screen
              if (parseInt(tooltip.style.left) < 10) {
                tooltip.style.left = "10px";
              }
              if (
                parseInt(tooltip.style.left) + tooltip.offsetWidth >
                window.innerWidth - 10
              ) {
                tooltip.style.left =
                  window.innerWidth - tooltip.offsetWidth - 10 + "px";
              }

              if (hideTimeout) {
                clearTimeout(hideTimeout);
              }
            };

            const hideTooltip = () => {
              if (tooltip) {
                hideTimeout = setTimeout(() => {
                  if (tooltip) {
                    tooltip.remove();
                    tooltip = null;
                  }
                }, 200);
              }
            };

            // Touch events for iOS
            element.addEventListener("touchstart", showTooltip, {
              passive: false,
            });
            element.addEventListener("touchend", (e) => {
              e.preventDefault();
              hideTooltip();
            });

            // Mouse events for desktop (hover)
            element.addEventListener("mouseenter", showTooltip);
            element.addEventListener("mouseleave", hideTooltip);

            // Click events as fallback
            element.addEventListener("click", (e) => {
              if (tooltip) {
                hideTooltip();
              } else {
                showTooltip(e);
              }
            });
          });
      }

      function createUrbanAnalysis() {
        const urbanConstituencies = Object.values(processedData)
          .filter(
            (c) =>
              c.year === 2019 &&
              (c.name.includes("Windhoek") ||
                c.name.includes("Swakopmund") ||
                c.name.includes("Walvis Bay") ||
                c.name.includes("Katutura"))
          )
          .slice(0, 8);

        const container = document.getElementById("urban-analysis");
        container.innerHTML = `
          <h4>Urban Vote Distribution Analysis</h4>
          <div class="takeaway-box orange">
            <strong>Key Takeaway:</strong> Urban constituencies show the most extreme vote fragmentation, with 6-7 opposition parties competing simultaneously in major cities like Windhoek and Swakopmund. This visualization reveals that in these urban centers, opposition parties collectively hold 55-65% of the vote, yet SWAPO wins because the anti-SWAPO vote is split across multiple parties. Urban coalition building represents the highest-impact strategy for opposition coordination.
            <div class="takeaway-footer">
              <strong>Tip:</strong> Hover over the bars in the chart below to see detailed vote breakdowns for each urban constituency. Explore how vote fragmentation varies across different cities.
            </div>
          </div>
          <div class="chart-container" id="urban-chart"></div>
          <div class="impact-box">
            <strong>Strategic Recommendation:</strong> Urban constituencies require formal electoral coordination 
            where opposition vote fragmentation is most pronounced. Priority should be placed on Windhoek, 
            Swakopmund, and Walvis Bay, where consolidated opposition efforts could yield the highest 
            electoral impact.
          </div>
        `;

        // Prepare data for grouped bar chart
        const chartData = urbanConstituencies.map((c) => ({
          constituency: c.name,
          region: c.region,
          parties: c.parties.slice(0, 4).map((p) => ({
            name: p.abbr,
            percentage: p.percentage,
            color: partyColors[p.abbr] || "#95A5A6",
          })),
        }));

        // Set up dimensions
        const margin = { top: 30, right: 200, bottom: 80, left: 180 };
        const containerWidth = container.offsetWidth || 800;
        const width = containerWidth - margin.left - margin.right;
        const height = Math.max(400, urbanConstituencies.length * 60);

        // Create or select existing tooltip
        let tooltip = d3.select(".d3-tooltip-urban");
        if (tooltip.empty()) {
          tooltip = d3
            .select("body")
            .append("div")
            .attr("class", "d3-tooltip d3-tooltip-urban")
            .style("opacity", 0);
        }

        // Clear any existing SVG
        d3.select("#urban-chart").selectAll("svg").remove();

        // Create SVG
        const svg = d3
          .select("#urban-chart")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);

        const g = svg
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Scales
        const xScale = d3.scaleLinear().domain([0, 100]).range([0, width]);
        const yScale = d3
          .scaleBand()
          .domain(chartData.map((d, i) => i))
          .range([0, height])
          .padding(0.2);

        // Create groups for each constituency
        const groups = g
          .selectAll(".constituency-group")
          .data(chartData)
          .enter()
          .append("g")
          .attr("class", "constituency-group")
          .attr("transform", (d, i) => `translate(0,${yScale(i)})`);

        // Add constituency labels
        groups
          .append("text")
          .attr("x", -10)
          .attr("y", yScale.bandwidth() / 2)
          .attr("dy", "0.35em")
          .attr("text-anchor", "end")
          .attr("class", "d3-axis-label")
          .style("font-size", "16px")
          .style("font-weight", "600")
          .text((d) =>
            d.constituency.length > 25
              ? d.constituency.substring(0, 25) + "..."
              : d.constituency
          );

        // Create bars for each party
        const barGroups = groups
          .selectAll(".party-bar")
          .data((d) => d.parties)
          .enter()
          .append("g")
          .attr("class", "party-bar");

        const maxParties = Math.max(...chartData.map((d) => d.parties.length));
        const barSpacing = yScale.bandwidth() / maxParties;
        const barHeight = barSpacing * 0.75;

        barGroups
          .append("rect")
          .attr("x", 0)
          .attr("y", (d, i) => i * barSpacing + (barSpacing - barHeight) / 2)
          .attr("width", (d) => xScale(d.percentage))
          .attr("height", barHeight)
          .attr("fill", (d) => d.color)
          .attr("rx", 3)
          .on("mouseover", function (event, d) {
            tooltip
              .style("opacity", 1)
              .html(
                `<strong>${d.name}</strong><br/>${d.percentage.toFixed(1)}%`
              )
              .style("left", event.pageX + 10 + "px")
              .style("top", event.pageY - 10 + "px");
          })
          .on("mouseout", function () {
            tooltip.style("opacity", 0);
          });

        // Add percentage labels on bars
        barGroups
          .append("text")
          .attr("x", (d) => xScale(d.percentage) + 5)
          .attr("y", (d, i) => i * barSpacing + barSpacing / 2)
          .attr("dy", "0.35em")
          .attr("class", "d3-axis-label")
          .style("font-size", "10px")
          .style("font-weight", "500")
          .text((d) => d.percentage.toFixed(1) + "%")
          .filter((d) => xScale(d.percentage) < 20)
          .attr("fill", "#333");

        // Add X axis
        const xAxis = d3.axisBottom(xScale).tickFormat((d) => d + "%");
        g.append("g")
          .attr("class", "d3-axis")
          .attr("transform", `translate(0,${height})`)
          .style("font-size", "16px")
          .call(xAxis);

        // Add axis label
        g.append("text")
          .attr("class", "d3-axis-label")
          .attr("transform", `translate(${width / 2},${height + 50})`)
          .style("text-anchor", "middle")
          .style("font-size", "18px")
          .style("font-weight", "600")
          .text("Vote Percentage (%)");

        // Add legend - deduplicate by party name
        const partyMap = new Map();
        chartData
          .flatMap((d) => d.parties)
          .forEach((p) => {
            if (!partyMap.has(p.name)) {
              partyMap.set(p.name, p.color);
            }
          });
        const legendData = Array.from(partyMap.entries())
          .map(([name, color]) => ({ name, color }))
          .slice(0, 8);

        const legend = g
          .append("g")
          .attr("transform", `translate(${width - 120},20)`);

        legend
          .selectAll(".legend-item")
          .data(legendData)
          .enter()
          .append("g")
          .attr("class", "legend-item")
          .attr("transform", (d, i) => `translate(0,${i * 28})`)
          .each(function (d) {
            const g = d3.select(this);
            g.append("rect")
              .attr("width", 16)
              .attr("height", 16)
              .attr("fill", d.color)
              .attr("rx", 4)
              .attr("stroke", "rgba(255, 255, 255, 0.1)")
              .attr("stroke-width", 1);
            g.append("text")
              .attr("x", 24)
              .attr("y", 13)
              .attr("class", "d3-axis-label")
              .style("font-size", "14px")
              .style("font-weight", "600")
              .style("fill", "#34495e")
              .text(d.name);
          });
      }

      function createTurnoutAnalysis() {
        const constituencies = [
          ...new Set(Object.values(processedData).map((c) => c.name)),
        ].slice(0, 10);

        const turnoutData = constituencies
          .map((name) => {
            const c2014 = Object.values(processedData).find(
              (c) => c.name === name && c.year === 2014
            );
            const c2019 = Object.values(processedData).find(
              (c) => c.name === name && c.year === 2019
            );

            if (c2014 && c2019) {
              return {
                name: name,
                turnout2014: c2014.turnout * 100,
                turnout2019: c2019.turnout * 100,
                change: (c2019.turnout - c2014.turnout) * 100,
              };
            }
            return null;
          })
          .filter((d) => d !== null)
          .sort((a, b) => b.name.localeCompare(a.name));

        const container = document.getElementById("turnout-analysis");
        container.innerHTML = `
          <h4>Voter Turnout Trends: 2014 vs 2019</h4>
          <div class="takeaway-box cyan">
            <strong>Key Takeaway:</strong> Declining voter turnout in opposition-leaning constituencies between 2014 and 2019 represents a critical mobilization opportunity. In many districts where opposition parties have strong support, participation rates dropped by 5-10 percentage points. If 2019 turnout had matched 2014 levels, an estimated 12,000-15,000 additional opposition votes could have been captured—enough to flip 2-3 closely contested constituencies. Turnout mobilization is a complementary strategy to vote coordination.
            <div class="takeaway-footer">
              <strong>Tip:</strong> Hover over the bars in the chart below to see detailed turnout comparisons between 2014 and 2019 for each constituency, including the change in participation rates.
            </div>
          </div>
          <div class="chart-container" id="turnout-chart"></div>
          <div class="impact-box">
            <strong>Mobilization Opportunity:</strong> Analysis reveals that declining voter turnout in 
            opposition strongholds between 2014 and 2019 represents a critical mobilization opportunity. 
            If 2019 participation rates had matched 2014 levels, an estimated 12,000-15,000 additional 
            opposition votes could have been captured, with the potential to flip 2-3 closely contested 
            constituencies.
          </div>
        `;

        // Set up dimensions
        const margin = { top: 30, right: 100, bottom: 100, left: 80 };
        const containerWidth = container.offsetWidth || 800;
        const width = containerWidth - margin.left - margin.right;
        const height = Math.max(400, turnoutData.length * 50);

        // Create or select existing tooltip
        let tooltip = d3.select(".d3-tooltip-turnout");
        if (tooltip.empty()) {
          tooltip = d3
            .select("body")
            .append("div")
            .attr("class", "d3-tooltip d3-tooltip-turnout")
            .style("opacity", 0);
        }

        // Clear any existing SVG
        d3.select("#turnout-chart").selectAll("svg").remove();

        // Create SVG
        const svg = d3
          .select("#turnout-chart")
          .append("svg")
          .attr("width", width + margin.left + margin.right)
          .attr("height", height + margin.top + margin.bottom);

        const g = svg
          .append("g")
          .attr("transform", `translate(${margin.left},${margin.top})`);

        // Scales
        const xScale = d3
          .scaleBand()
          .domain(turnoutData.map((d, i) => i))
          .range([0, width])
          .padding(0.3);

        const yScale = d3
          .scaleLinear()
          .domain([
            0,
            d3.max(turnoutData, (d) => Math.max(d.turnout2014, d.turnout2019)) *
              1.1,
          ])
          .nice()
          .range([height, 0]);

        const color2014 = "#3498DB";
        const color2019 = "#E74C3C";

        // Create groups for each constituency
        const groups = g
          .selectAll(".constituency-group")
          .data(turnoutData)
          .enter()
          .append("g")
          .attr("class", "constituency-group")
          .attr("transform", (d, i) => `translate(${xScale(i)},0)`);

        // Add constituency labels
        groups
          .append("text")
          .attr("x", xScale.bandwidth() / 2)
          .attr("y", height + 40)
          .attr("text-anchor", "middle")
          .attr("class", "d3-axis-label")
          .style("font-size", "10px")
          .attr("transform", (d, i) => {
            const angle = -45;
            const x = xScale.bandwidth() / 2;
            const y = height + 40;
            return `rotate(${angle} ${x} ${y})`;
          })
          .text((d) =>
            d.name.length > 15 ? d.name.substring(0, 15) + "..." : d.name
          );

        // Add bars for 2014
        groups
          .append("rect")
          .attr("x", 0)
          .attr("width", xScale.bandwidth() / 2 - 2)
          .attr("y", (d) => yScale(d.turnout2014))
          .attr("height", (d) => height - yScale(d.turnout2014))
          .attr("fill", color2014)
          .attr("rx", 3)
          .on("mouseover", function (event, d) {
            tooltip
              .style("opacity", 1)
              .html(
                `<strong>2014</strong><br/>${
                  d.constituency || d.name
                }<br/>${d.turnout2014.toFixed(1)}%`
              )
              .style("left", event.pageX + 10 + "px")
              .style("top", event.pageY - 10 + "px");
          })
          .on("mouseout", function () {
            tooltip.style("opacity", 0);
          });

        // Add bars for 2019
        groups
          .append("rect")
          .attr("x", xScale.bandwidth() / 2 + 2)
          .attr("width", xScale.bandwidth() / 2 - 2)
          .attr("y", (d) => yScale(d.turnout2019))
          .attr("height", (d) => height - yScale(d.turnout2019))
          .attr("fill", color2019)
          .attr("rx", 3)
          .on("mouseover", function (event, d) {
            tooltip
              .style("opacity", 1)
              .html(
                `<strong>2019</strong><br/>${
                  d.constituency || d.name
                }<br/>${d.turnout2019.toFixed(1)}%`
              )
              .style("left", event.pageX + 10 + "px")
              .style("top", event.pageY - 10 + "px");
          })
          .on("mouseout", function () {
            tooltip.style("opacity", 0);
          });

        // Add value labels on bars
        groups
          .selectAll(".value-label-2014")
          .data((d) => [d])
          .enter()
          .append("text")
          .attr("class", "value-label-2014")
          .attr("x", xScale.bandwidth() / 4)
          .attr("y", (d) => yScale(d.turnout2014) - 5)
          .attr("text-anchor", "middle")
          .attr("class", "d3-axis-label")
          .style("font-size", "9px")
          .style("font-weight", "500")
          .text((d) => d.turnout2014.toFixed(1) + "%")
          .filter((d) => yScale(d.turnout2014) < height - 30);

        groups
          .selectAll(".value-label-2019")
          .data((d) => [d])
          .enter()
          .append("text")
          .attr("class", "value-label-2019")
          .attr("x", (xScale.bandwidth() * 3) / 4)
          .attr("y", (d) => yScale(d.turnout2019) - 5)
          .attr("text-anchor", "middle")
          .attr("class", "d3-axis-label")
          .style("font-size", "9px")
          .style("font-weight", "500")
          .text((d) => d.turnout2019.toFixed(1) + "%")
          .filter((d) => yScale(d.turnout2019) < height - 30);

        // Add change indicators - positioned higher above bars
        groups
          .selectAll(".change-indicator")
          .data((d) => [d])
          .enter()
          .append("text")
          .attr("class", "change-indicator")
          .attr("x", xScale.bandwidth() / 2)
          .attr(
            "y",
            (d) => Math.min(yScale(d.turnout2014), yScale(d.turnout2019)) - 30
          )
          .attr("text-anchor", "middle")
          .attr("class", "d3-axis-label")
          .style("font-size", "12px")
          .style("font-weight", "700")
          .attr("fill", "#E74C3C")
          .text((d) => (d.change > 0 ? "+" : "") + d.change.toFixed(1) + "%");

        // Add Y axis
        const yAxis = d3.axisLeft(yScale).tickFormat((d) => d + "%");
        g.append("g").attr("class", "d3-axis").call(yAxis);

        // Add axis label
        g.append("text")
          .attr("class", "d3-axis-label")
          .attr("transform", "rotate(-90)")
          .attr("y", -50)
          .attr("x", -height / 2)
          .style("text-anchor", "middle")
          .text("Turnout (%)");

        // Add legend
        const legend = g
          .append("g")
          .attr("transform", `translate(${width - 80},20)`);

        const legendItems = [
          { label: "2014", color: color2014 },
          { label: "2019", color: color2019 },
        ];

        legend
          .selectAll(".legend-item")
          .data(legendItems)
          .enter()
          .append("g")
          .attr("class", "legend-item")
          .attr("transform", (d, i) => `translate(0,${i * 25})`)
          .each(function (d) {
            const g = d3.select(this);
            g.append("rect")
              .attr("width", 15)
              .attr("height", 15)
              .attr("fill", d.color)
              .attr("rx", 3);
            g.append("text")
              .attr("x", 20)
              .attr("y", 12)
              .attr("class", "d3-axis-label")
              .style("font-size", "12px")
              .text(d.label);
          });
      }

      function updateStats() {
        try {
          const constituencies2019 = Object.values(processedData).filter(
            (c) => c && c.year === 2019
          );

          if (constituencies2019.length === 0) return;

          // Calculate SWAPO wins - check both winner field and parties array
          let swapoWins = 0;
          constituencies2019.forEach((c) => {
            // First check if winner is set and is SWAPO
            if (c.winner && isSWAPOParty(c.winner)) {
              swapoWins++;
            } else if (c.parties && c.parties.length > 0) {
              // Fallback: check if the top party is SWAPO (parties should already be sorted by votes)
              const topParty = c.parties[0];
              if (topParty && isSWAPOParty(topParty)) {
                swapoWins++;
              }
            }
          });

          const totalConstEl = document.getElementById("total-const");
          const swapoConstEl = document.getElementById("swapo-const");

          if (totalConstEl) {
            totalConstEl.textContent = constituencies2019.length;
          }

          if (swapoConstEl) {
            swapoConstEl.textContent = swapoWins.toString();
          }
        } catch (error) {
          // Still try to set a default value if element exists
          const swapoConstEl = document.getElementById("swapo-const");
          if (swapoConstEl) {
            swapoConstEl.textContent = "0";
          }
        }
      }

      // Load data when page loads
      loadData();

      // Re-render charts on orientation/resize for mobile responsiveness
      window.addEventListener(
        "resize",
        debounce(function () {
          // Recompute widths and redraw charts that depend on container width
          try {
            createUrbanAnalysis();
          } catch (e) {}
          try {
            createTurnoutAnalysis();
          } catch (e) {}
        }, 200)
      );
    </script>
  </body>
</html>
